# ifj21


# <p align="center">ZADÃNÃ PROJEKTU Z PÅ˜EDMÄšTÅ® IFJ A IAL</p>
<p align="center">ZbynÄ›k KÅ™ivka, Adam KÃ¶vÃ¡ri, Dominika RegÃ©ciovÃ¡</br>
email: {krivka, ikovari, iregeciova}@fit.vut.cz</br>
22. zÃ¡Å™Ã­ 2021</p>

## 1 ObecnÃ© informace

**NÃ¡zev projektu:** Implementace pÅ™ekladaÄe imperativnÃ­ho jazyka IFJ21.  
**Informace:** diskuznÃ­ fÃ³rum a wiki strÃ¡nky pÅ™edmÄ›tu IFJ v IS FIT.  
**PokusnÃ© odevzdÃ¡nÃ­:** Ätvrtek 25. listopadu 2021, 23:59 (nepovinnÃ©).  
**Datum odevzdÃ¡nÃ­:** stÅ™eda 8. prosince 2021, 23:59.  
**ZpÅ¯sob odevzdÃ¡nÃ­:** prostÅ™ednictvÃ­m IS FIT do datovÃ©ho skladu pÅ™edmÄ›tu IFJ.  

**HodnocenÃ­:**

- Do pÅ™edmÄ›tu IFJ zÃ­skÃ¡ kaÅ¾dÃ½ maximÃ¡lnÄ› 25 bodÅ¯ (15 celkovÃ¡ funkÄnost projektu
(tzv. programovÃ¡ ÄÃ¡st), 5 dokumentace, 5 obhajoba).  
- Do pÅ™edmÄ›tu IAL zÃ­skÃ¡ kaÅ¾dÃ½ maximÃ¡lnÄ› 15 bodÅ¯ (5 celkovÃ¡ funkÄnost projektu, 5
obhajoba, 5 dokumentace).  
- Max. 35 % bodÅ¯ VaÅ¡eho individuÃ¡lnÃ­ho hodnocenÃ­ zÃ¡kladnÃ­ funkÄnosti do pÅ™edmÄ›tu
IFJ navÃ­c za tvÅ¯rÄÃ­ pÅ™Ã­stup (rÅ¯znÃ¡ rozÅ¡Ã­Å™enÃ­ apod.).  
- UdÄ›lenÃ­ zÃ¡poÄtu z IFJ i IAL je podmÃ­nÄ›no zÃ­skÃ¡nÃ­m min. 20 bodÅ¯ v prÅ¯bÄ›hu
semestru. NavÃ­c v IFJ z tÄ›chto 20 bodÅ¯ musÃ­te zÃ­skat nejmÃ©nÄ› 4 body za programovou ÄÃ¡st projektu.  
- Dokumentace bude hodnocena nejvÃ½Å¡e polovinou bodÅ¯ z hodnocenÃ­ funkÄnosti projektu, bude takÃ© reflektovat procentuÃ¡lnÃ­ rozdÄ›lenÃ­ bodÅ¯ a bude zaokrouhlena na celÃ©
body.  
- Body zapisovanÃ© za programovou ÄÃ¡st vÄetnÄ› rozÅ¡Ã­Å™enÃ­ budou takÃ© zaokrouhleny a v pÅ™Ã­padÄ› pÅ™esÃ¡hnutÃ­ 15 bodÅ¯ zapsÃ¡ny do termÃ­nu â€Projekt - PrÃ©miovÃ© bodyâ€œ v IFJ.  

**Å˜eÅ¡itelskÃ© tÃ½my:**

- Projekt budou Å™eÅ¡it tÅ™Ã­ aÅ¾ ÄtyÅ™ÄlennÃ© tÃ½my. TÃ½my s jinÃ½m poÄtem ÄlenÅ¯ jsou nepÅ™Ã­pustnÃ©.  
- Registrace do tÃ½mÅ¯ se provÃ¡dÃ­ pÅ™ihlÃ¡Å¡enÃ­m na pÅ™Ã­sluÅ¡nou variantu zadÃ¡nÃ­ v IS FIT. Registrace je dvoufÃ¡zovÃ¡. V prvnÃ­ fÃ¡zi se na jednotlivÃ© varianty projektu pÅ™ihlaÅ¡ujÃ­
pouze vedoucÃ­ tÃ½mÅ¯ (kapacita je omezena na 1). Ve druhÃ© fÃ¡zi se pak sami doregistrujÃ­ ostatnÃ­ ÄlenovÃ© (kapacita bude zvÃ½Å¡ena na 4). VedoucÃ­ tÃ½mÅ¯ budou mÃ­t plnou pravomoc nad sloÅ¾enÃ­m svÃ©ho tÃ½mu. RovnÄ›Å¾ vzÃ¡jemnÃ¡ komunikace mezi vyuÄujÃ­cÃ­mi a tÃ½my bude probÃ­hat nejlÃ©pe prostÅ™ednictvÃ­m vedoucÃ­ch (ideÃ¡lnÄ› v kopii dalÅ¡Ã­m ÄlenÅ¯m tÃ½mu). Ve vÃ½sledku bude u kaÅ¾dÃ©ho tÃ½mu prvnÄ› zaregistrovanÃ½ Älen povaÅ¾ovÃ¡n za vedoucÃ­ho tohoto tÃ½mu. VÅ¡echny termÃ­ny k projektu najdete v IS FIT a dalÅ¡Ã­ informace na strÃ¡nkÃ¡ch pÅ™edmÄ›tu.  
- ZadÃ¡nÃ­ obsahuje dvÄ› varianty, kterÃ© se liÅ¡Ã­ pouze ve zpÅ¯sobu implementace tabulky
symbolÅ¯ a jsou identifikovanÃ© Å™Ã­mskou ÄÃ­slicÃ­ I nebo II. KaÅ¾dÃ½ tÃ½m mÃ¡ svÃ© identifikaÄnÃ­ ÄÃ­slo, na kterÃ© se vÃ¡Å¾e vybranÃ¡ varianta zadÃ¡nÃ­. VÃ½bÄ›r variant se provÃ¡dÃ­
pÅ™ihlÃ¡Å¡enÃ­m do skupiny danÃ©ho tÃ½mu v IS FIT.  

## 2 ZadÃ¡nÃ­

VytvoÅ™te program v jazyce C, kterÃ½ naÄte zdrojovÃ½ kÃ³d zapsanÃ½ ve zdrojovÃ©m jazyce IFJ21
a pÅ™eloÅ¾Ã­ jej do cÃ­lovÃ©ho jazyka IFJcode21 (mezikÃ³d). JestliÅ¾e probÄ›hne pÅ™eklad bez chyb,
vracÃ­ se nÃ¡vratovÃ¡ hodnota 0 (nula). JestliÅ¾e doÅ¡lo k nÄ›jakÃ© chybÄ›, vracÃ­ se nÃ¡vratovÃ¡ hodnota nÃ¡sledovnÄ›:</br>
- 1 - chyba v programu v rÃ¡mci lexikÃ¡lnÃ­ analÃ½zy (chybnÃ¡ struktura aktuÃ¡lnÃ­ho lexÃ©mu).</br>
- 2 - chyba v programu v rÃ¡mci syntaktickÃ© analÃ½zy (chybnÃ¡ syntaxe programu).</br>
- 3 - sÃ©mantickÃ¡ chyba v programu â€“ nedefinovanÃ¡ funkce/promÄ›nnÃ¡, pokus o redefinici promÄ›nnÃ©, atp.</br>
- 4 - sÃ©mantickÃ¡ chyba v pÅ™Ã­kazu pÅ™iÅ™azenÃ­ (typovÃ¡ nekompatibilita).</br>
- 5 - sÃ©mantickÃ¡ chyba v programu â€“ Å¡patnÃ½ poÄet/typ parametrÅ¯ Äi nÃ¡vratovÃ½ch hodnot
u volÃ¡nÃ­ funkce Äi nÃ¡vratu z funkce.</br>
- 6 - sÃ©mantickÃ¡ chyba typovÃ© kompatibility v aritmetickÃ½ch, Å™etÄ›zcovÃ½ch a relaÄnÃ­ch</br>
vÃ½razech.
- 7 - ostatnÃ­ sÃ©mantickÃ© chyby.</br>
- 8 - bÄ›hovÃ¡ chyba pÅ™i prÃ¡ci s neoÄekÃ¡vanou hodnotou `nil`.</br>
- 9 - bÄ›hovÃ¡ chyba celoÄÃ­selnÃ©ho dÄ›lenÃ­ nulovou konstantou.</br>
- 99 - internÃ­ chyba pÅ™ekladaÄe tj. neovlivnÄ›nÃ¡ vstupnÃ­m programem (napÅ™. chyba alokace pamÄ›ti atd.).

PÅ™ekladaÄ bude naÄÃ­tat Å™Ã­dicÃ­ program v jazyce IFJ21 ze standardnÃ­ho vstupu a generovat vÃ½slednÃ½ mezikÃ³d v jazyce IFJcode21 (viz kapitola 10) na standardnÃ­ vÃ½stup. VÅ¡echna chybovÃ¡ hlÃ¡Å¡enÃ­, varovÃ¡nÃ­ a ladicÃ­ vÃ½pisy provÃ¡dÄ›jte na standardnÃ­ chybovÃ½ vÃ½stup; tj. bude
se jednat o konzolovou aplikaci (tzv. filtr) bez grafickÃ©ho uÅ¾ivatelskÃ©ho rozhranÃ­. Pro interpretaci vÃ½slednÃ©ho programu v cÃ­lovÃ©m jazyce IFJcode21 bude na strÃ¡nkÃ¡ch pÅ™edmÄ›tu k dispozici interpret.</br>
KlÃ­ÄovÃ¡ slova jsou sÃ¡zena tuÄnÄ› a nÄ›kterÃ© lexÃ©my jsou pro zvÃ½Å¡enÃ­ Äitelnosti v apostrofech, pÅ™iÄemÅ¾ znak apostrofu nenÃ­ v takovÃ©m pÅ™Ã­padÄ› souÄÃ¡stÃ­ jazyka!

## 3 Popis programovacÃ­ho jazyka

Jazyk IFJ21 je zjednoduÅ¡enou podmnoÅ¾inou jazyka Teal, kterÃ½ vznikl doplnÄ›nÃ­m statickÃ©ho typovÃ¡nÃ­ do jazyka Lua. Teal je staticky typovanÃ½ imperativnÃ­ jazyk.

### 3.1 ObecnÃ© vlastnosti a datovÃ© typy

V programovacÃ­m jazyce IFJ21 zÃ¡leÅ¾Ã­ na velikosti pÃ­smen u identifikÃ¡torÅ¯ i klÃ­ÄovÃ½ch slov
(tzv. _case-sensitive_).
- _IdentifikÃ¡tor_ je definovÃ¡n jako neprÃ¡zdnÃ¡ posloupnost pÃ­smen, ÄÃ­slic a znaku podtrÅ¾Ã­tka ('\_â€™) zaÄÃ­najÃ­cÃ­ pÃ­smenem nebo podtrÅ¾Ã­tkem.
- Jazyk IFJ21 obsahuje navÃ­c nÃ­Å¾e uvedenÃ¡ _klÃ­ÄovÃ¡ slova_, kterÃ¡ majÃ­ specifickÃ½ vÃ½znam, a proto se nesmÄ›jÃ­ vyskytovat jako identifikÃ¡tory:
    ```
      do, else, end, function, global, if, integer, local, nil, number, require, return, string, then, while
    ```

- _CeloÄÃ­selnÃ½ literÃ¡l_ (rozsah C-int) je tvoÅ™en neprÃ¡zdnou posloupnostÃ­ ÄÃ­slic a vyjadÅ™uje hodnotu celÃ©ho nezÃ¡pornÃ©ho ÄÃ­sla v desÃ­tkovÃ© soustavÄ›.
- _DesetinnÃ½ literÃ¡l_ (rozsah C-double) takÃ© vyjadÅ™uje nezÃ¡pornÃ¡ ÄÃ­sla v desÃ­tkovÃ© soustavÄ›, pÅ™iÄemÅ¾ literÃ¡l je tvoÅ™en celou a desetinnou ÄÃ¡stÃ­, nebo celou ÄÃ¡stÃ­ a exponentem, nebo celou a desetinnou ÄÃ¡stÃ­ a exponentem. CelÃ¡ i desetinnÃ¡ ÄÃ¡st je tvoÅ™ena neprÃ¡zdnou posloupnostÃ­ ÄÃ­slic. Exponent je celoÄÃ­selnÃ½, zaÄÃ­nÃ¡ znakem â€™`e`â€™ nebo â€™`E`â€™, nÃ¡sleduje nepovinnÃ© znamÃ©nko â€™`+`â€™ (plus) nebo â€™`-`â€™ (mÃ­nus) a poslednÃ­ ÄÃ¡stÃ­ je neprÃ¡zdnÃ¡ posloupnost ÄÃ­slic. Mezi jednotlivÃ½mi ÄÃ¡stmi nesmÃ­ bÃ½t jinÃ½ znak, celou a desetinnou ÄÃ¡st oddÄ›luje znak â€™`.`â€™ (teÄka).
- _Å˜etÄ›zcovÃ½ literÃ¡l_ je oboustrannÄ› ohraniÄen dvojitÃ½mi uvozovkami (", ASCII hodnota 34). TvoÅ™Ã­ jej libovolnÃ½ poÄet znakÅ¯ zapsanÃ½ch na jedinÃ©m Å™Ã¡dku programu. MoÅ¾nÃ½ je i prÃ¡zdnÃ½ Å™etÄ›zec (`""`). Znaky s ASCII hodnotou vÄ›tÅ¡Ã­ neÅ¾ 31 (mimo ") lze zapisovat pÅ™Ã­mo. NÄ›kterÃ© dalÅ¡Ã­ znaky lze zapisovat pomocÃ­ escape sekvence: â€™`\"`â€™, â€™`\n`â€™, â€™`\t`â€™, â€™`\\`â€™. Jejich vÃ½znam se shoduje s odpovÃ­dajÃ­cÃ­mi znakovÃ½mi konstantami jazyka Lua. NeexistujÃ­cÃ­ escape sekvence vede na lexikÃ¡lnÃ­ chybu. Znak v Å™etÄ›zci mÅ¯Å¾e bÃ½t zadÃ¡n takÃ© pomocÃ­ obecnÃ© escape sekvence â€™\dddâ€™, kde ddd je prÃ¡vÄ› tÅ™Ã­mÃ­stnÃ© desÃ­tkovÃ© ÄÃ­slo od 001 do 255. DÃ©lka Å™etÄ›zce nenÃ­ omezena (resp. jen dostupnou velikostÃ­ haldy). NapÅ™Ã­klad Å™etÄ›zcovÃ½ literÃ¡l 
    ```
    "Ahoj\n\"Sve'te \\\034" 
    ``` 
    reprezentuje Å™etÄ›zec</br>
    ```
    Ahoj
    "Sve'te \"
    ```
    NeuvaÅ¾ujte Å™etÄ›zce, kterÃ© obsahujÃ­ vÃ­cebajtovÃ© znaky kÃ³dovÃ¡nÃ­ Unicode (napÅ™. UTF-8).
- _DatovÃ© typy_ pro jednotlivÃ© literÃ¡ly jsou oznaÄeny `integer`, `number` a `string`, kde
do typu `number` spadajÃ­ i celoÄÃ­selnÃ© hodnoty. SpeciÃ¡lnÃ­m pÅ™Ã­padem je typ _nil_, kterÃ½
nabÃ½vÃ¡ pouze hodnoty `nil`. Hodnoty `nil` mohou nabÃ½vat vÅ¡echny promÄ›nnÃ©.
- _Term_ je libovolnÃ½ literÃ¡l (celoÄÃ­selnÃ½, desetinnÃ½, Å™etÄ›zcovÃ½ Äi `nil`) nebo identifikÃ¡tor
promÄ›nnÃ©.
- Jazyk IFJ21 podporuje _Å™Ã¡dkovÃ©_ i _blokovÃ©_ komentÃ¡Å™e stejnÄ› jako jazyk Teal/Lua. Å˜Ã¡dkovÃ½ komentÃ¡Å™ zaÄÃ­nÃ¡ dvojicÃ­ pomlÄek (â€™`--`â€™, ASCII hodnota 45) a za komentÃ¡Å™ je povaÅ¾ovÃ¡no vÅ¡e, co nÃ¡sleduje aÅ¾ do konce Å™Ã¡dku. BlokovÃ½ komentÃ¡Å™ zaÄÃ­nÃ¡ posloupnostÃ­ symbolÅ¯ â€™`--[[`â€™ a je ukonÄen dvojicÃ­ symbolÅ¯ â€™`]]`â€™. VnoÅ™enÃ© blokovÃ© komentÃ¡Å™e neuvaÅ¾ujte.

## 4 Struktura jazyka

IFJ21 je strukturovanÃ½ programovacÃ­ jazyk podporujÃ­cÃ­ definice promÄ›nnÃ½ch a uÅ¾ivatelskÃ½ch funkcÃ­ vÄetnÄ› jejich rekurzivnÃ­ho volÃ¡nÃ­. VstupnÃ­m bodem provÃ¡dÄ›nÃ©ho programu je neoznaÄenÃ¡ nesouvislÃ¡ sekvence pÅ™Ã­kazÅ¯ volÃ¡nÃ­ funkce bez navracenÃ­ hodnoty mezi deklaracemi a definicemi uÅ¾ivatelskÃ½ch funkcÃ­, tzv. _hlavnÃ­ tÄ›lo_ programu.

### 4.1 ZÃ¡kladnÃ­ struktura jazyka

Program se sklÃ¡dÃ¡ z prologu nÃ¡sledovanÃ©ho sekvencÃ­ deklaracÃ­ a definic uÅ¾ivatelskÃ½ch funkcÃ­ a pÅ™Ã­kazÅ¯ volÃ¡nÃ­ funkce bez navracenÃ­ hodnoty. V tÄ›lech uÅ¾ivatelskÃ½ch funkcÃ­ lze potom definovat lokÃ¡lnÃ­ promÄ›nnÃ©, pouÅ¾Ã­vat pÅ™Ã­kazy pÅ™iÅ™azenÃ­, vÄ›tvenÃ­, iterace a volÃ¡nÃ­ funkcÃ­.  

Prolog se sklÃ¡dÃ¡ z jednoho Å™Ã¡dku:  
```lua
require "ifj21"
```

Mezi jednotlivÃ½mi tokeny se mÅ¯Å¾e vyskytovat libovolnÃ½ poÄet bÃ­lÃ½ch znakÅ¯ (mezera, tabulÃ¡tor, komentÃ¡Å™ a odÅ™Ã¡dkovÃ¡nÃ­), takÅ¾e jednotlivÃ© konstrukce jazyka IFJ21 lze zapisovat na jednom Äi vÃ­ce Å™Ã¡dcÃ­ch nebo mÅ¯Å¾e bÃ½t na jednom Å™Ã¡dku vÃ­ce pÅ™Ã­kazÅ¯ jazyka IFJ21. Je-li to tÅ™eba, jsou pÅ™Ã­kazy oddÄ›leny bÃ­lÃ½mi znaky. Na zaÄÃ¡tku a konci zdrojovÃ©ho textu se smÃ­ vyskytovat libovolnÃ½ poÄet bÃ­lÃ½ch znakÅ¯.  
Struktura definice uÅ¾ivatelskÃ½ch funkcÃ­ a takÃ© popis jednotlivÃ½ch pÅ™Ã­kazÅ¯ je v nÃ¡sledujÃ­cÃ­ch sekcÃ­ch.

#### 4.1.1 PromÄ›nnÃ©

PromÄ›nnÃ© jazyka IFJ21 jsou pouze lokÃ¡lnÃ­ a majÃ­ rozsah platnosti v bloku, ve kterÃ©m byly definovÃ¡ny, od mÃ­sta jejich definice aÅ¾ po konec tohoto bloku. _Blokem_ je libovolnÃ¡ sekvence pÅ™Ã­kazÅ¯ zapsÃ¡na v tÄ›le funkce, v rÃ¡mci vÄ›tve podmÃ­nÄ›nÃ©ho pÅ™Ã­kazu nebo pÅ™Ã­kazu cyklu. Blok a jeho podbloky tvoÅ™Ã­ tzv. _rozsah platnosti_, kde je promÄ›nnÃ¡ dostupnÃ¡, pokud nenÃ­ v podbloku pÅ™ekryta definicÃ­ stejnÄ› pojmenovanÃ© promÄ›nnÃ©.  

Definice promÄ›nnÃ© se provÃ¡dÃ­ pomocÃ­ pÅ™Ã­kazu definice promÄ›nnÃ© s povinnÃ½m urÄenÃ­m typu a s volitelnou inicializacÃ­. DetailnÃ­ syntaxe bude popsÃ¡na v sekci 4.3.  
V rÃ¡mci jednoho bloku nelze definovat vÃ­ce promÄ›nnÃ½ch stejnÃ©ho jmÃ©na. DÃ¡le nelze definovat promÄ›nnou stejnÃ©ho jmÃ©na jako nÄ›kterÃ¡ jiÅ¾ deklarovanÃ¡ Äi definovanÃ¡ funkce.  

NenÃ­-li typ inicializaÄnÃ­ho vÃ½razu staticky (pÅ™i pÅ™ekladu) kompatibilnÃ­ s typem inicializovanÃ© promÄ›nnÃ©, jde o chybu 4. VÃ½raz, jehoÅ¾ typ lze odvodit staticky, mÅ¯Å¾e obsahovat literÃ¡ly, jiÅ¾ definovanÃ© promÄ›nnÃ©, operÃ¡tory i zÃ¡vorky, nebo se mÅ¯Å¾e jednat o volÃ¡nÃ­ funkce s nÃ¡vratovou hodnotou kompatibilnÃ­ho typu. Definice promÄ›nnÃ© stejnÃ©ho jmÃ©na jako mÃ¡ jinÃ¡ promÄ›nnÃ¡ ve stejnÃ©m bloku vede na chybu 3. KaÅ¾dÃ¡ promÄ›nnÃ¡ musÃ­ bÃ½t definovÃ¡na pÅ™ed jejÃ­m pouÅ¾itÃ­m, jinak se jednÃ¡ o sÃ©mantickou chybu 3. PÅ™i definici promÄ›nnÃ© stejnÃ©ho jmÃ©na jako nÄ›kterÃ¡ promÄ›nnÃ¡ z nadÅ™azenÃ© ÃºrovnÄ› je viditelnÃ¡ pouze pozdÄ›ji definovanÃ¡ promÄ›nnÃ¡, kterÃ¡ je na danÃ©m mÃ­stÄ› platnÃ¡. OstatnÃ­ promÄ›nnÃ© stejnÃ©ho jmÃ©na mohou bÃ½t platnÃ©, i kdyÅ¾ nejsou v danÃ© ÄÃ¡sti programu viditelnÃ©.

### 4.2 Deklarace a definice uÅ¾ivatelskÃ½ch funkcÃ­

Definice funkce se sklÃ¡dÃ¡ z hlaviÄky a tÄ›la funkce. KaÅ¾dÃ¡ uÅ¾ivatelskÃ¡ funkce s danÃ½m identifikÃ¡torem je definovÃ¡na nejvÃ½Å¡e jednou, jinak dochÃ¡zÃ­ k chybÄ› 3. Definice funkce nemusÃ­ vÅ¾dy lexikÃ¡lnÄ› pÅ™edchÃ¡zet kÃ³du pro volÃ¡nÃ­ tÃ©to funkce. UvaÅ¾ujte napÅ™Ã­klad vzÃ¡jemnÃ© rekurzivnÃ­ volÃ¡nÃ­ funkcÃ­ (tj. funkce ğ‘“ volÃ¡ funkci ğ‘”, kterÃ¡ opÄ›t mÅ¯Å¾e volat funkci ğ‘“ ).  

V pÅ™Ã­padÄ›, Å¾e je volÃ¡na funkce, kterÃ¡ jeÅ¡tÄ› nebyla definovÃ¡na, musÃ­ jejÃ­mu volÃ¡nÃ­ pÅ™edchÃ¡zet alespoÅˆ jejÃ­ deklarace. Funkce mÅ¯Å¾e bÃ½t deklarovÃ¡na nejvÃ½Å¡e jednou, jinak dochÃ¡zÃ­ k chybÄ› 3. K tÃ© takÃ© dochÃ¡zÃ­, pokud u deklarace a definice funkce neodpovÃ­dajÃ­ seznamy parametrÅ¯ nebo seznamy nÃ¡vratovÃ½ch typÅ¯, Äi pokud deklarovanÃ¡ funkce nenÃ­ nakonec definovÃ¡na. PÅ™Ã­klad:  
```lua
global foo : function(string) : string

function bar(param : string) : string
  return foo (param)
end

function foo(param:string):string
  return bar(param)
end
```

_Definice funkce_ je vÃ­ceÅ™Ã¡dkovÃ¡ konstrukce (hlaviÄka a tÄ›lo) ve tvaru:
```lua
function id ( seznam_parametrÅ¯ ) : seznam_nÃ¡vratovÃ½ch_typÅ¯
  sloÅ¾enÃ½_pÅ™Ã­kaz
end
```

- HlaviÄka definice funkce sahÃ¡ od klÃ­ÄovÃ©ho slova `function` aÅ¾ po urÄenÃ­ nÃ¡vratovÃ©ho typu funkce, pak nÃ¡sleduje tÄ›lo funkce zakonÄenÃ© klÃ­ÄovÃ½m slovem `end`.
- Seznam parametrÅ¯ je tvoÅ™en posloupnostÃ­ definic parametrÅ¯ oddÄ›lenÃ½ch ÄÃ¡rkou, pÅ™iÄemÅ¾ za poslednÃ­m parametrem se ÄÃ¡rka neuvÃ¡dÃ­. Seznam mÅ¯Å¾e bÃ½t i prÃ¡zdnÃ½. KaÅ¾dÃ¡
definice parametru obsahuje identifikÃ¡tor parametru a za dvojteÄkou jeho datovÃ½ typ:
_identifikÃ¡tor_parametru : typ_  
    Parametry jsou vÅ¾dy pÅ™edÃ¡vÃ¡ny hodnotou.
- Seznam nÃ¡vratovÃ½ch typÅ¯ je posloupnost datovÃ½ch typÅ¯, jejichÅ¾ hodnoty funkce vracÃ­. OddÄ›lovaÄem v seznamu nÃ¡vratovÃ½ch typÅ¯ je opÄ›t ÄÃ¡rka. PÅ™Ã­klad:
    ```lua
    require "ifj21"
    function concat (x : string, y : string) : string, integer
      return x .. y, 0 end
    function main()
      local x : string
      local ret: integer
      x, ret = concat("ahoj", "svete")
    end
    main()
    ```
    Seznam nÃ¡vratovÃ½ch typÅ¯ mÅ¯Å¾e bÃ½t i prÃ¡zdnÃ½, coÅ¾ je vyuÅ¾ito u funkcÃ­ bez navracenÃ­ hodnoty, kterÃ© mohou bÃ½t volÃ¡ny napÅ™. v hlavnÃ­m tÄ›le programu IFJ21.
- TÄ›lo funkce je tvoÅ™eno sekvencÃ­ pÅ™Ã­kazÅ¯ (viz sekce 4.3) ukonÄenÃ½ch odpovÃ­dajÃ­cÃ­m klÃ­ÄovÃ½m slovem `end`. Parametry funkce jsou chÃ¡pÃ¡ny jako pÅ™eddefinovanÃ© lokÃ¡lnÃ­
promÄ›nnÃ©.  

KaÅ¾dÃ¡ funkce s nÃ¡vratovou hodnotou vracÃ­ jednu nebo vÃ­ce hodnot danÃ© vyhodnocenÃ­m vÃ½razu v pÅ™Ã­kazu `return`. V pÅ™Ã­padÄ› chybÄ›jÃ­cÃ­ nÃ¡vratovÃ© hodnoty kvÅ¯li neprovedenÃ­ Å¾Ã¡dnÃ©ho pÅ™Ã­kazu `return` bude navracen odpovÃ­dajÃ­cÃ­ poÄet hodnot `nil`. Pokud typy nÃ¡vratovÃ½ch hodnot neodpovÃ­dajÃ­ hlaviÄce funkce, dojde k chybÄ› 5. Definice vnoÅ™enÃ½ch funkcÃ­
je zakÃ¡zÃ¡na.

### 4.3 Syntaxe a sÃ©mantika pÅ™Ã­kazÅ¯

NenÃ­-li Å™eÄeno jinak, tak kaÅ¾dÃ¡ _sekvence pÅ™Ã­kazÅ¯_ v nÃ¡sledujÃ­cÃ­ch popisech strukturovanÃ½ch pÅ™Ã­kazÅ¯ tvoÅ™Ã­ novÃ½ blok, kterÃ½ mÃ¡ vlastnÃ­ rozsah platnosti promÄ›nnÃ½ch v nÄ›m definovanÃ½ch. Sekvence pÅ™Ã­kazÅ¯ mÅ¯Å¾e bÃ½t i prÃ¡zdnÃ¡.  

DÃ­lÄÃ­m pÅ™Ã­kazem se rozumÃ­:  
- _PÅ™Ã­kaz definice promÄ›nnÃ©_:
    `local` _id : datovytyp = init_vÃ½raz_ci_volani_fce_  
    SÃ©mantika pÅ™Ã­kazu je nÃ¡sledujÃ­cÃ­: PÅ™Ã­kaz novÄ› definuje lokÃ¡lnÃ­ promÄ›nnou, kterÃ¡ v danÃ©m bloku jeÅ¡tÄ› nebyla definovÃ¡na (lze takto pÅ™ekrÃ½t promÄ›nnou definovanou v pÅ™Ã­padnÃ©m obklopujÃ­cÃ­m bloku), jinak dojde k chybÄ› 3. Typ novÄ› definovanÃ© promÄ›nnÃ© _id_ je tedy dÃ¡n staticky jako _datovytyp_ a nelze jej mÄ›nit. Je-li pÅ™Ã­tomen i volitelnÃ½ inicializaÄnÃ­ vÃ½raz Äi inicializaÄnÃ­ volÃ¡nÃ­ funkce s nÃ¡vratovou hodnotou, je _id_ inicializovÃ¡no vÃ½slednou hodnotou, jinak je implicitnÄ› inicializovÃ¡no na `nil`. VyhodnocenÃ­ inicializaÄnÃ­ho vÃ½razu Äi inicializaÄnÃ­ho volÃ¡nÃ­ funkce je popsÃ¡no v pÅ™Ã­kazu pÅ™iÅ™azenÃ­ a pÅ™Ã­kazu volÃ¡nÃ­ funkce.
- _PÅ™Ã­kaz pÅ™iÅ™azenÃ­_:
    _id<sub>1</sub>, id<sub2</sub>, â€¦, id<sub>ğ‘›</sub> = vÃ½raz<sub>1</sub> , vÃ½raz<sub2</sub> , â€¦, vÃ½raz<sub>ğ‘›</sub>_
    kde ğ‘› â‰¥ 1. Syntakticky slouÅ¾Ã­ ÄÃ¡rka (â€™`,`â€™) jako oddÄ›lovaÄ pÅ™i ğ‘› â‰¥ 2, takÅ¾e za poslednÃ­m identifikÃ¡torem Äi vÃ½razem se ÄÃ¡rka nepÃ­Å¡e. SÃ©mantika pÅ™Ã­kazu je nÃ¡sledujÃ­cÃ­: PÅ™Ã­kaz provÃ¡dÃ­ pÅ™iÅ™azenÃ­ hodnot operandÅ¯ vpravo (vÃ½razy _vÃ½raz<sub>1</sub>_ aÅ¾ _vÃ½raz<sub>n</sub>_; viz kapitola 5) po Å™adÄ› do odpovÃ­dajÃ­cÃ­ch promÄ›nnÃ½ch _id<sub>1</sub>_ aÅ¾ _id<sub>ğ‘›</sub>_ tak, Å¾e nejprve provede vyhodnocenÃ­ vÅ¡ech vÃ½razÅ¯ (operandÅ¯ napravo v poÅ™adÃ­ zprava do leva), zapamatovÃ¡nÃ­
si tÄ›chto vÃ½sledkÅ¯ a nÃ¡slednÄ› pÅ™iÅ™azenÃ­ tÄ›chto vÃ½sledkÅ¯ jednotlivÃ½m promÄ›nnÃ½m. VÅ¡echny promÄ›nnÃ© nalevo od `=` musÃ­ bÃ½t dÅ™Ã­ve definovanÃ© a platnÃ©.
- _PodmÃ­nÄ›nÃ½ pÅ™Ã­kaz_:
    ```lua
    if vÃ½raz then
      sekvence_pÅ™Ã­kazÅ¯1
    else
      sekvence_pÅ™Ã­kazÅ¯2
    end
    ```
    SÃ©mantika pÅ™Ã­kazu je nÃ¡sledujÃ­cÃ­: Nejprve se vyhodnotÃ­ danÃ½ vÃ½raz. Pokud je vyhodnocenÃ½ vÃ½raz pravdivÃ½, vykonÃ¡ se _sekvence_pÅ™Ã­kazÅ¯<sub>1</sub>_, jinak se vykonÃ¡ _sekvence_pÅ™Ã­kazÅ¯<sub>2</sub>_. Pokud vÃ½slednÃ¡ hodnota vÃ½razu nenÃ­ pravdivostnÃ­ (tj. pravda Äi nepravda - v zÃ¡kladnÃ­m zadÃ¡nÃ­ pouze jako vÃ½sledek aplikace relaÄnÃ­ch operÃ¡torÅ¯ dle sekce 5.1), tak se hodnota `nil` bere jako nepravda a ostatnÃ­ hodnoty jako pravda (vÄetnÄ› prÃ¡zdnÃ©ho Å™etÄ›zce nebo nuly).
- _PÅ™Ã­kaz cyklu_:
    ```lua
    while vÃ½raz do
      sekvence_pÅ™Ã­kazÅ¯
    end
    ```
    PÅ™Ã­kaz cyklu se sklÃ¡dÃ¡ z hlaviÄky a tÄ›la tvoÅ™enÃ©ho _sekvencÃ­_pÅ™Ã­kazÅ¯_.
    SÃ©mantika pÅ™Ã­kazu cyklu je nÃ¡sledujÃ­cÃ­: Opakuje se provÃ¡dÄ›nÃ­ _sekvence_pÅ™Ã­kazÅ¯_ (viz pÅ™Ã­kazy v tÃ©to sekci) tak dlouho, dokud je hodnota vÃ½razu pravdivÃ¡. Pravidla pro urÄenÃ­ pravdivosti vÃ½razu jsou stejnÃ¡ jako u vÃ½razu v podmÃ­nÄ›nÃ©m pÅ™Ã­kazu. PromÄ›nnÃ© definovanÃ© aÅ¾ v tÄ›le cyklu nejsou viditelnÃ© v hlaviÄce cyklu.
- _VolÃ¡nÃ­ vestavÄ›nÃ© Äi uÅ¾ivatelem definovanÃ© funkce_:
    _id<sub>1</sub>, id<sub>2</sub>, ..., id<sub>n</sub> = nÃ¡zev_funkce(seznam_vstupnÃ­ch_parametrÅ¯)_
    kde ğ‘› â‰¥ 1. Syntakticky slouÅ¾Ã­ ÄÃ¡rka (â€™`,`â€™) jako oddÄ›lovaÄ pÅ™i ğ‘› â‰¥ 2, takÅ¾e za poslednÃ­m skuteÄnÃ½m parametrem se ÄÃ¡rka nepÃ­Å¡e.
    _Seznam_vstupnÃ­ch_parametrÅ¯_ je seznam termÅ¯ (viz sekce 3.1) oddÄ›lenÃ½ch ÄÃ¡rkami. Seznam mÅ¯Å¾e bÃ½t i prÃ¡zdnÃ½. SÃ©mantika vestavÄ›nÃ½ch funkcÃ­ bude popsÃ¡na v kapitole 6. SÃ©mantika volÃ¡nÃ­ uÅ¾ivatelem definovanÃ½ch funkcÃ­ je nÃ¡sledujÃ­cÃ­: PÅ™Ã­kaz zajistÃ­ pÅ™edÃ¡nÃ­ parametrÅ¯ hodnotou a pÅ™edÃ¡nÃ­ Å™Ã­zenÃ­ do tÄ›la funkce. V pÅ™Ã­padÄ›, Å¾e pÅ™Ã­kaz volÃ¡nÃ­ funkce obsahuje jinÃ½ poÄet nebo typy parametrÅ¯, neÅ¾ funkce oÄekÃ¡vÃ¡ (tedy neÅ¾ je uvedeno v jejÃ­ hlaviÄce, a to i u vestavÄ›nÃ½ch funkcÃ­), jednÃ¡ se o chybu 5. Po dokonÄenÃ­ provÃ¡dÄ›nÃ­ zavolanÃ© funkce je pÅ™iÅ™azena nÃ¡vratovÃ¡ hodnota (hodnoty) do promÄ›nnÃ©/promÄ›nnÃ½ch _id<sub>1</sub>_ aÅ¾ _id<sub>n</sub>_ a bÄ›h programu pokraÄuje bezprostÅ™ednÄ› za pÅ™Ã­kazem volÃ¡nÃ­ prÃ¡vÄ› provedenÃ© funkce. Neobsahuje-li tÄ›lo funkce pÅ™Ã­kaz `return`, vracÃ­ funkce odpovÃ­dajÃ­cÃ­ poÄet hodnot `nil`. Pokud funkce vracÃ­ mÃ©nÄ› hodnot, neÅ¾ je oÄekÃ¡vÃ¡no dle poÄtu promÄ›nnÃ½ch _id<sub>1</sub>_ aÅ¾ _id<sub>n</sub>_, dojde k chybÄ› 5. Pokud naopak funkce vracÃ­ vÃ­ce hodnot (tj. vÃ­ce neÅ¾ ğ‘›), jsou tyto hodnoty zahazovÃ¡ny. TypovÃ¡ nekompatibilita mezi nÃ¡vratovou hodnotou a odpovÃ­dajÃ­cÃ­ promÄ›nnou pro jejÃ­ uloÅ¾enÃ­ vede na chybu 5. VÅ¡echny promÄ›nnÃ© nalevo od = jiÅ¾ musÃ­ bÃ½t definovÃ¡ny.
- _VolÃ¡nÃ­ funkce bez navracenÃ­ hodnoty_:
    _nÃ¡zev_funkce(seznam_vstupnÃ­ch_parametrÅ¯)_
    PÅ™i volÃ¡nÃ­ funkce bez navracenÃ­ hodnoty je sÃ©mantika pÅ™Ã­kazu analogickÃ¡ pÅ™edchozÃ­mu, ale pÅ™Ã­padnÃ© nÃ¡vratovÃ© hodnoty nebudou vyuÅ¾ity. _Seznam_vstupnÃ­ch_parametrÅ¯_ mÃ¡ stejnÃ½ vÃ½znam jako v pÅ™edchozÃ­ Å™Ã­dicÃ­ struktuÅ™e. TÃ­mto zpÅ¯sobem lze volat i funkci, kterÃ¡ dle svÃ© definice nÄ›jakÃ© hodnoty vracÃ­, ty jsou vÅ¡ak pÅ™i takovÃ©mto volÃ¡nÃ­ zahozeny. Tento druh volÃ¡nÃ­ se smÃ­ vyskytovat jako jedinÃ½ v hlavnÃ­m tÄ›le programu (tj. mezi definicemi/deklaracemi funkcÃ­), kdy je typickÃ©, Å¾e je takto na konci programu volÃ¡na hlavnÃ­ funkce nebo vÃ­ce funkcÃ­.
â€¢ _PÅ™Ã­kaz nÃ¡vratu z funkce_:
    `return` _seznam_vÃ½razÅ¯_
    PÅ™Ã­kaz je typicky pouÅ¾it v tÄ›le funkce, kterÃ¡ mÃ¡ neprÃ¡zdnÃ½ nÃ¡vratovÃ½ typ. U funkcÃ­ bez nÃ¡vratovÃ© hodnoty mÅ¯Å¾e bÃ½t pÅ™Ã­kaz nÃ¡vratu z funkce zcela vynechÃ¡n nebo pouÅ¾ita varianta bez seznamu vÃ½razÅ¯. Jeho sÃ©mantika je nÃ¡sledujÃ­cÃ­: Dojde k vyhodnocenÃ­ jednotlivÃ½ch ÄÃ¡rkou oddÄ›lenÃ½ch vÃ½razÅ¯ v _seznam_vÃ½razÅ¯_ (tj. zÃ­skÃ¡nÃ­ ğ‘›-tice nÃ¡vratovÃ½ch hodnot, kde ğ‘› â‰¥ 0, a to zleva doprava), okamÅ¾itÃ©mu ukonÄenÃ­ provÃ¡dÄ›nÃ­ tÄ›la funkce a nÃ¡vratu do mÃ­sta volÃ¡nÃ­, kam funkce vrÃ¡tÃ­ vypoÄtenou nÃ¡vratovou hodnotu/hodnoty. Je-li poÄet vÃ½razÅ¯ vÃ½slednÃ½ch hodnot nekompatibilnÃ­ s nÃ¡vratovÃ½mi typy danÃ© funkce, jsou chybÄ›jÃ­cÃ­ hodnoty doplnÄ›ny speciÃ¡lnÃ­ hodnotou `nil` a pÅ™ebÃ½vajÃ­cÃ­ zpÅ¯sobÃ­ chybu 5.
    
## 5 VÃ½razy

VÃ½razy jsou tvoÅ™eny termy, zÃ¡vorkami a aritmetickÃ½mi, Å™etÄ›zcovÃ½mi a relaÄnÃ­mi operÃ¡tory.

V IFJ21 je typ `integer` podtypem typu `number`, takÅ¾e je moÅ¾nÃ© vyuÅ¾Ã­t typ `integer` tam, kde se oÄekÃ¡vÃ¡ typ `number` (tzv. typovÃ¡ kompatibilita). Je-li tÅ™eba, tak dojde i k implicitnÃ­ typovÃ© konverzi z `integer` na `number`.

Pro chybnÃ© kombinace datovÃ½ch typÅ¯ ve vÃ½razech vracejte chybu 6.

### 5.1 AritmetickÃ©, Å™etÄ›zcovÃ© a relaÄnÃ­ operÃ¡tory

StandardnÃ­ binÃ¡rnÃ­ operÃ¡tory `+`, `-`, `*` znaÄÃ­ sÄÃ­tÃ¡nÃ­, odÄÃ­tÃ¡nÃ­ a nÃ¡sobenÃ­. Jsou-li oba operandy typu `integer`, je i vÃ½sledek typu `integer`. Jsou-li oba operandy typu `number` nebo jeden `integer` a druhÃ½ `number`, vÃ½sledek je typu `number`. InfixovÃ½ binÃ¡rnÃ­ operÃ¡tor `..` provÃ¡dÃ­ se dvÄ›ma Å™etÄ›zcovÃ½mi operandy konkatenaci. PrefixovÃ½ unÃ¡rnÃ­ operÃ¡tor `#` slouÅ¾Ã­ pro zÃ­skÃ¡nÃ­ dÃ©lky (poÄet znakÅ¯) Å™etÄ›zce zadanÃ©ho jako jedinÃ½ operand vpravo. NapÅ™. `#"x\nz"` vracÃ­ 3.

OperÃ¡tor `/` znaÄÃ­ dÄ›lenÃ­ dvou ÄÃ­selnÃ½ch operandÅ¯ a vÃ½sledek je typu `number`. Jsou-li oba operandy celoÄÃ­selnÃ©, lze vyuÅ¾Ã­t operÃ¡tor `//` pro celoÄÃ­selnÃ© dÄ›lenÃ­. PÅ™i dÄ›lenÃ­ nulou operÃ¡torem `//` ale i `/` nastÃ¡vÃ¡ chyba 9. Pro provedenÃ­ explicitnÃ­ho pÅ™etypovÃ¡nÃ­ z `number` na `integer` lze pouÅ¾Ã­t vestavÄ›nou funkci `tointeger` (viz kapitola 6).

Pro relaÄnÃ­ operÃ¡tory `<`, `>`, `<=`, `>=`, `==`, `~=` platÃ­, Å¾e vÃ½sledkem porovnÃ¡nÃ­ je pravdivostnÃ­ hodnota a Å¾e majÃ­ stejnou sÃ©mantiku jako v jazyce Teal/Lua. Tyto operÃ¡tory pracujÃ­ s operandy stejnÃ½ch nebo kompatibilnÃ­ch typÅ¯, a to `integer`, `number` nebo `string`. PomocÃ­ `==` a `~=` lze provÃ¡dÄ›t i test na speciÃ¡lnÃ­ hodnotu `nil`, ale v pÅ™Ã­padÄ› aplikace jinÃ½ch operÃ¡torÅ¯ na nil dochÃ¡zÃ­ k bÄ›hovÃ© chybÄ› 8. U Å™etÄ›zcÅ¯ se porovnÃ¡nÃ­ provÃ¡dÃ­ lexikograficky. Bez rozÅ¡Ã­Å™enÃ­ BOOLTHEN nenÃ­ s vÃ½sledkem porovnÃ¡nÃ­ moÅ¾nÃ© dÃ¡le pracovat a lze jej vyuÅ¾Ã­t pouze u podmÃ­nek pÅ™Ã­kazÅ¯ `if` a `while`.

### 5.2 Priorita operÃ¡torÅ¯

Prioritu operÃ¡torÅ¯ lze explicitnÄ› upravit zÃ¡vorkovÃ¡nÃ­m podvÃ½razÅ¯. NÃ¡sledujÃ­cÃ­ tabulka udÃ¡vÃ¡ priority operÃ¡torÅ¯ (nahoÅ™e nejvyÅ¡Å¡Ã­):  

<table align="center">
    <tr>
      <td><b>Priorita</b></td>
      <td><b>OperÃ¡tory</b></td>
      <td><b>Asociativita</b></td>
    </tr>
    <tr>
      <td>0</td>
      <td>#</td>
      <td>unÃ¡rnÃ­</td>
    </tr>
    <tr>
      <td>1</td>
      <td>* / //</td>
      <td>levÃ¡</td>
    </tr>
    <tr>
      <td>2</td>
      <td>+ - </td>
      <td>levÃ¡</td>
    </tr>
    <tr>
      <td>3</td>
      <td>..</td>
      <td>pravÃ¡</td>
    </tr>
    <tr>
      <td>4</td>
      <td> < <= > >= == ~=</td>
      <td>levÃ¡</td>
    </tr>
</table>

## 6 VestavÄ›nÃ© funkce

PÅ™ekladaÄ bude poskytovat nÄ›kterÃ© zÃ¡kladnÃ­ vestavÄ›nÃ© funkce, kterÃ© bude moÅ¾nÃ© vyuÅ¾Ã­t v programech jazyka IFJ21. Pro generovÃ¡nÃ­ kÃ³du vestavÄ›nÃ½ch funkcÃ­ lze vÃ½hodnÄ› vyuÅ¾Ã­t specializovanÃ½ch instrukcÃ­ jazyka IFJcode21.  

PÅ™i pouÅ¾itÃ­ Å¡patnÃ©ho typu termu v parametrech nÃ¡sledujÃ­cÃ­ch vestavÄ›nÃ½ch funkcÃ­ dochÃ¡zÃ­ k chybÄ› 5.  

_VestavÄ›nÃ© funkce pro naÄÃ­tÃ¡nÃ­ literÃ¡lÅ¯ a vÃ½pis termÅ¯_:
- _PÅ™Ã­kazy pro naÄÃ­tÃ¡nÃ­ hodnot_:
    ```lua
    function reads() : string
    function readi() : integer
    function readn() : number
    ```
    VestavÄ›nÃ© funkce ze standardnÃ­ho vstupu naÄtou jeden Å™Ã¡dek ukonÄenÃ½ odÅ™Ã¡dkovÃ¡nÃ­m. Funkce `reads` tento Å™etÄ›zec vrÃ¡tÃ­ bez symbolu konce Å™Ã¡dku (naÄÃ­tanÃ½ Å™etÄ›zec
nepodporuje escape sekvence). V pÅ™Ã­padÄ› `readi` a `readn` jsou okolnÃ­ bÃ­lÃ© znaky ignorovÃ¡ny. JakÃ½koli jinÃ½ nevhodnÃ½ znak pÅ™ed Äi za samotnÃ½m ÄÃ­slem je znÃ¡mkou
Å¡patnÃ©ho formÃ¡tu a vede na nÃ¡vratovou hodnotu `nil`. Funkce `readi` naÄÃ­tÃ¡ a vracÃ­ celÃ© ÄÃ­slo, `readn` desetinnÃ© ÄÃ­slo. ObÄ› funkce podporujÃ­ i naÄÃ­tÃ¡nÃ­ hexadecimÃ¡lnÃ­ho zÃ¡pisu ÄÃ­sla (napÅ™. _0x1FA3_ nebo _0x1F.F1p-1_, kde je Å¡estnÃ¡ctkovÃ¡ soustava detekovÃ¡na podÅ™etÄ›zci _0x_ a _p_). V pÅ™Ã­padÄ› chybÄ›jÃ­cÃ­ hodnoty na vstupu (napÅ™. naÄtenÃ­ EOF) nebo jejÃ­ho Å¡patnÃ©ho formÃ¡tu je vrÃ¡cena hodnota `nil`.
-  _PÅ™Ã­kaz pro vÃ½pis hodnot_:
  `function write ( term1 , term2 , â€¦, termğ‘› )`
    VestavÄ›nÃ½ pÅ™Ã­kaz mÃ¡ libovolnÃ½ poÄet parametrÅ¯ tvoÅ™enÃ½ch termy oddÄ›lenÃ½mi ÄÃ¡rkou. SÃ©mantika pÅ™Ã­kazu je nÃ¡sledujÃ­cÃ­: PostupnÄ› zleva doprava prochÃ¡zÃ­ termy (podrobnÄ›ji popsÃ¡ny v sekci 3.1) a vypisuje jejich hodnoty na standardnÃ­ vÃ½stup ihned za sebe bez Å¾Ã¡dnÃ½ch oddÄ›lovaÄÅ¯ dle typu v patÅ™iÄnÃ©m formÃ¡tu. Za poslednÃ­m termem se tÃ©Å¾ nic nevypisuje! Hodnota termu typu `integer` bude vytiÅ¡tÄ›na pomocÃ­ `'%d'`, hodnota termu typu `number` pak pomocÃ­ `'%a'`. Funkce `write` nemÃ¡ nÃ¡vratovou hodnotu.
    
_VestavÄ›nÃ© funkce pro konverzi ÄÃ­selnÃ½ch typÅ¯_:
- `function tointeger(f : number) : integer`
    VracÃ­ hodnotu desetinnÃ©ho parametru f pÅ™evedenou na celoÄÃ­selnou hodnotu oÅ™Ã­znutÃ­m desetinnÃ© ÄÃ¡sti. Je-li ğ‘“ `nil`, vracÃ­ funkce tÃ©Å¾ `nil`.
    
_VestavÄ›nÃ© funkce pro prÃ¡ci s Å™etÄ›zci_:
- `function substr(s : string, i : number, j : number) : string` 
    VrÃ¡tÃ­ podÅ™etÄ›zec zadanÃ©ho Å™etÄ›zce ğ‘ . DruhÃ½m parametrem ğ‘– je dÃ¡n index zaÄÃ¡tku poÅ¾adovanÃ©ho podÅ™etÄ›zce (poÄÃ­tÃ¡no od jedniÄky) a tÅ™etÃ­m parametrem ğ‘— je index konce poÅ¾adovanÃ©ho podÅ™etÄ›zce (poÄÃ­tÃ¡no od jedniÄky). Je-li index ğ‘–, nebo ğ‘— mimo meze 1 aÅ¾ #s, nebo je-li ğ‘— < ğ‘–, vracÃ­ funkce prÃ¡zdnÃ½ Å™etÄ›zec. Je-li nÄ›kterÃ½ parametr `nil`, nastÃ¡vÃ¡ chyba 8.
- `function ord(s : string, i : integer) : integer`
    VrÃ¡tÃ­ ordinÃ¡lnÃ­ hodnotu (ASCII) znaku na pozici ğ‘– v Å™etÄ›zci ğ‘ . Je-li jeden z parametrÅ¯ `nil`, nastÃ¡vÃ¡ chyba 8. Je-li index ğ‘– mimo meze Å™etÄ›zce (1 aÅ¾ #s), vracÃ­ funkce `nil`.
- `function chr(i : integer) : string`
    VrÃ¡tÃ­ jednoznakovÃ½ Å™etÄ›zec se znakem, jehoÅ¾ ASCII kÃ³d je zadÃ¡n parametrem ğ‘–. PÅ™Ã­pad, kdy je ğ‘– mimo interval [0; 255], vede na hodnotu `nil`. Je-li ğ‘– `nil`, nastÃ¡vÃ¡ chyba 8.
    
## 7 Implementace tabulky symbolÅ¯

Tabulka symbolÅ¯ bude implementovÃ¡na pomocÃ­ abstraktnÃ­ datovÃ© struktury, kterÃ¡ je ve variantÄ› zadÃ¡nÃ­ pro danÃ½ tÃ½m oznaÄena Å™Ã­mskÃ½mi ÄÃ­slicemi I-II, a to nÃ¡sledovnÄ›:

I) Tabulku symbolÅ¯ implementujte pomocÃ­ binÃ¡rnÃ­ho vyhledÃ¡vacÃ­ho stromu.  
II) Tabulku symbolÅ¯ implementujte pomocÃ­ tabulky s rozptÃ½lenÃ½mi poloÅ¾kami.

Implementace tabulky symbolÅ¯ bude uloÅ¾ena v souboru `symtable.c` (pÅ™Ã­padnÄ› `symtable.h`). VÃ­ce viz sekce 12.2.

## 8 PÅ™Ã­klady

Tato kapitola uvÃ¡dÃ­ tÅ™i jednoduchÃ© pÅ™Ã­klady Å™Ã­dicÃ­ch programÅ¯ v jazyce IFJ21.

### VÃ½poÄet faktoriÃ¡lu (iterativnÄ›)

```lua
-- Program 1: Vypocet faktorialu (iterativne)
require "ifj21"

function main() -- uzivatelska funkce bez parametru
  local a : integer
  local vysl : integer = 0
  write("Zadejte cislo pro vypocet faktorialu\n")
  a = readi()
  if a == nil then
    write("a je nil\n") return
  else
  end
  if a < 0 then
    write("Faktorial nelze spocitat\n")
  else
    vysl = 1
    while a > 0 do
      vysl = vysl * a a = a - 1 -- dva prikazy
    end
    write("Vysledek je: ", vysl, "\n")
  end
end

main() -- prikaz hlavniho tela programu
```

### 8.2 VÃ½poÄet faktoriÃ¡lu (rekurzivnÄ›)

```lua
-- Program 2: Vypocet faktorialu (rekurzivne)
require "ifj21"

function factorial(n : integer) : integer
  local n1 : integer = n - 1
  if n < 2 then
    return 1
  else
    local tmp : integer = factorial(n1)
    return n * tmp
  end
end

function main()
  write("Zadejte cislo pro vypocet faktorialu: ")
  local a : integer = readi()
  if a ~= nil then
    if a < 0 then
      write("Faktorial nejde spocitat!", "\n")
    else
      local vysl : integer = factorial(a)
      write("Vysledek je ", vysl, "\n")
    end
  else
    write("Chyba pri nacitani celeho cisla!\n")
  end
end

main()
```

### 8.3 PrÃ¡ce s Å™etÄ›zci a vestavÄ›nÃ½mi funkcemi

```lua
-- Program 3: Prace s retezci a vestavenymi funkcemi
require "ifj21"

function main()
  local s1 : string = "Toto je nejaky text"
  local s2 : string = s1 .. ", ktery jeste trochu obohatime"
  write(s1, "\010", s2)local s1len:integer=#s1 local s1len4: integer=s1len
  s1len = s1len - 4 s1 = substr(s2, s1len, s1len4) s1len = s1len + 1
  write("4 znaky od", s1len, ". znaku v \"", s2, "\":", s1, "\n")
  write("Zadejte serazenou posloupnost vsech malych pismen a-h, ")
    write("pricemz se pismena nesmeji v posloupnosti opakovat: ")
  s1 = reads()
  if s1 ~= nil then
    while s1 ~= "abcdefgh" do
      write("\n", "Spatne zadana posloupnost, zkuste znovu:")
      s1 = reads()
    end
  else
  end
end

main()
```

## 9 DoporuÄenÃ­ k testovÃ¡nÃ­

ProgramovacÃ­ jazyk IFJ21 je schvÃ¡lnÄ› navrÅ¾en tak, aby byl tÃ©mÄ›Å™ kompatibilnÃ­ s podmnoÅ¾inou jazyka Teal. Pokud si student nenÃ­ jistÃ½, co by mÄ›l cÃ­lovÃ½ kÃ³d pÅ™esnÄ› vykonat pro nÄ›jakÃ½ zdrojovÃ½ kÃ³d jazyka IFJ21, mÅ¯Å¾e si to ovÄ›Å™it nÃ¡sledovnÄ›. Z IS FIT si stÃ¡hne ze SouborÅ¯ k pÅ™edmÄ›tu IFJ ze sloÅ¾ky Projekt soubor `ifj21.tl` obsahujÃ­cÃ­ kÃ³d, kterÃ½ doplÅˆuje kompatibilitu IFJ21 s pÅ™ekladaÄem tl jazyka Teal 0.13.2 na serveru `merlin`. Soubor `ifj21.tl` obsahuje definice vestavÄ›nÃ½ch funkcÃ­, kterÃ© jsou souÄÃ¡stÃ­ jazyka IFJ21, ale chybÃ­ v potÅ™ebnÃ© formÄ› v jazyce Teal/Lua.

VÃ¡Å¡ program v jazyce IFJ21 uloÅ¾enÃ½ napÅ™Ã­klad v souboru `testPrg.tl19` pak lze provÃ©st na serveru merlin napÅ™Ã­klad pomocÃ­ pÅ™Ã­kazu:
`tl run testPrg.tl < test.in > test.out`

TÃ­m lze jednoduÅ¡e zkontrolovat, co by mÄ›l provÃ©st zadanÃ½ zdrojovÃ½ kÃ³d, resp. vygenerovanÃ½ cÃ­lovÃ½ kÃ³d. Je ale potÅ™eba si uvÄ›domit, Å¾e jazyk Teal je nadmnoÅ¾inou jazyka IFJ21, a tudÃ­Å¾ mÅ¯Å¾e zpracovat i konstrukce, kterÃ© nejsou v IFJ21 povolenÃ© (napÅ™. bohatÅ¡Ã­ syntaxe a sÃ©mantika vÄ›tÅ¡iny pÅ™Ã­kazÅ¯, Äi dokonce zpÄ›tnÃ© nekompatibility). VÃ½Äet tÄ›chto odliÅ¡nostÃ­ bude uveden na wiki strÃ¡nkÃ¡ch a mÅ¯Å¾ete jej diskutovat na fÃ³ru pÅ™edmÄ›tu IFJ.

## 10 CÃ­lovÃ½ jazyk IFJcode21

CÃ­lovÃ½ jazyk IFJcode21 je mezikÃ³dem, kterÃ½ zahrnuje instrukce tÅ™Ã­adresnÃ© (typicky se tÅ™emi argumenty) a zÃ¡sobnÃ­kovÃ© (typicky bez parametrÅ¯ a pracujÃ­cÃ­ s hodnotami na datovÃ©m zÃ¡sobnÃ­ku). KaÅ¾dÃ¡ instrukce se sklÃ¡dÃ¡ z operaÄnÃ­ho kÃ³du (klÃ­ÄovÃ© slovo s nÃ¡zvem instrukce), u kterÃ©ho nezÃ¡leÅ¾Ã­ na velikosti pÃ­smen (tj. case insensitive). Zbytek instrukcÃ­ tvoÅ™Ã­ operandy, u kterÃ½ch na velikosti pÃ­smen zÃ¡leÅ¾Ã­ (tzv. case sensitive). Operandy oddÄ›lujeme libovolnÃ½m nenulovÃ½m poÄtem mezer Äi tabulÃ¡torÅ¯. OdÅ™Ã¡dkovÃ¡nÃ­ slouÅ¾Ã­ pro oddÄ›lenÃ­ jednotlivÃ½ch instrukcÃ­, takÅ¾e na kaÅ¾dÃ©m Å™Ã¡dku je maximÃ¡lnÄ› jedna instrukce a nenÃ­ povoleno jednu instrukci zapisovat na vÃ­ce Å™Ã¡dkÅ¯. KaÅ¾dÃ½ operand je tvoÅ™en promÄ›nnou, konstantou nebo nÃ¡vÄ›Å¡tÃ­m. V IFJcode21 jsou podporovÃ¡ny jednoÅ™Ã¡dkovÃ© komentÃ¡Å™e zaÄÃ­najÃ­cÃ­ mÅ™Ã­Å¾kou (#).  
KÃ³d v jazyce IFJcode21 zaÄÃ­nÃ¡ ÃºvodnÃ­m Å™Ã¡dkem s teÄkou nÃ¡sledovanou jmÃ©nem jazyka:  
`.IFJcode21`

### 10.1 HodnotÃ­cÃ­ interpret ic21int

Pro hodnocenÃ­ a testovÃ¡nÃ­ mezikÃ³du v IFJcode21 je k dispozici interpret pro pÅ™Ã­kazovou
Å™Ã¡dku (`ic21int`):  
`ic21int prg.code < prg.in > prg.out`
ChovÃ¡nÃ­ interpretu lze upravovat pomocÃ­ pÅ™epÃ­naÄÅ¯/parametrÅ¯ pÅ™Ã­kazovÃ© Å™Ã¡dky. NÃ¡povÄ›du k nim zÃ­skÃ¡te pomocÃ­ pÅ™epÃ­naÄe `--help`.

ProbÄ›hne-li interpretace bez chyb, vracÃ­ se nÃ¡vratovÃ¡ hodnota 0 (nula). ChybovÃ½m pÅ™Ã­padÅ¯m odpovÃ­dajÃ­ nÃ¡sledujÃ­cÃ­ nÃ¡vratovÃ© hodnoty:
- 50 - chybnÄ› zadanÃ© vstupnÃ­ parametry na pÅ™Ã­kazovÃ©m Å™Ã¡dku pÅ™i spouÅ¡tÄ›nÃ­ interpretu.
- 51 - chyba pÅ™i analÃ½ze (lexikÃ¡lnÃ­, syntaktickÃ¡) vstupnÃ­ho kÃ³du v IFJcode21.
- 52 - chyba pÅ™i sÃ©mantickÃ½ch kontrolÃ¡ch vstupnÃ­ho kÃ³du v IFJcode21.
- 53 - bÄ›hovÃ¡ chyba interpretace â€“ Å¡patnÃ© typy operandÅ¯.
- 54 - bÄ›hovÃ¡ chyba interpretace â€“ pÅ™Ã­stup k neexistujÃ­cÃ­ promÄ›nnÃ© (rÃ¡mec existuje).
- 55 - bÄ›hovÃ¡ chyba interpretace â€“ rÃ¡mec neexistuje (napÅ™. ÄtenÃ­ z prÃ¡zdnÃ©ho zÃ¡sobnÃ­ku rÃ¡mcÅ¯).
- 56 - bÄ›hovÃ¡ chyba interpretace â€“ chybÄ›jÃ­cÃ­ hodnota (v promÄ›nnÃ©, na datovÃ©m zÃ¡sobnÃ­ku, nebo v zÃ¡sobnÃ­ku volÃ¡nÃ­).
- 57 - bÄ›hovÃ¡ chyba interpretace â€“ Å¡patnÃ¡ hodnota operandu (napÅ™. dÄ›lenÃ­ nulou, Å¡patnÃ¡ nÃ¡vratovÃ¡ hodnota instrukce EXIT).
- 58 - bÄ›hovÃ¡ chyba interpretace â€“ chybnÃ¡ prÃ¡ce s Å™etÄ›zcem.
- 60 - internÃ­ chyba interpretu tj. neovlivnÄ›nÃ¡ vstupnÃ­m programem (napÅ™. chyba alokace pamÄ›ti, chyba pÅ™i otvÃ­rÃ¡nÃ­ souboru s Å™Ã­dicÃ­m programem atd.).

### 10.2 PamÄ›Å¥ovÃ½ model

Hodnoty bÄ›hem interpretace nejÄastÄ›ji uklÃ¡dÃ¡me do pojmenovanÃ½ch promÄ›nnÃ½ch, kterÃ© jsou sdruÅ¾ovÃ¡ny do tzv. rÃ¡mcÅ¯, coÅ¾ jsou v podstatÄ› slovnÃ­ky promÄ›nnÃ½ch s jejich hodnotami.  
IFJcode21 nabÃ­zÃ­ tÅ™i druhy rÃ¡mcÅ¯:
- globÃ¡lnÃ­, znaÄÃ­me GF (Global Frame), kterÃ½ je na zaÄÃ¡tku interpretace automaticky inicializovÃ¡n jako prÃ¡zdnÃ½; slouÅ¾Ã­ pro uklÃ¡dÃ¡nÃ­ globÃ¡lnÃ­ch promÄ›nnÃ½ch;
- lokÃ¡lnÃ­, znaÄÃ­me LF (Local Frame), kterÃ½ je na zaÄÃ¡tku nedefinovÃ¡n a odkazuje na vrcholovÃ½/aktuÃ¡lnÃ­ rÃ¡mec na zÃ¡sobnÃ­ku rÃ¡mcÅ¯; slouÅ¾Ã­ pro uklÃ¡dÃ¡nÃ­ lokÃ¡lnÃ­ch promÄ›nnÃ½ch funkcÃ­ (zÃ¡sobnÃ­k rÃ¡mcÅ¯ lze s vÃ½hodou vyuÅ¾Ã­t pÅ™i zanoÅ™enÃ©m Äi rekurzivnÃ­m volÃ¡nÃ­ funkcÃ­);
- doÄasnÃ½, znaÄÃ­me TF (Temporary Frame), kterÃ½ slouÅ¾Ã­ pro chystÃ¡nÃ­ novÃ©ho nebo Ãºklid starÃ©ho rÃ¡mce (napÅ™. pÅ™i volÃ¡nÃ­ nebo dokonÄovÃ¡nÃ­ funkce), jenÅ¾ mÅ¯Å¾e bÃ½t pÅ™esunut na zÃ¡sobnÃ­k rÃ¡mcÅ¯ a stÃ¡t se aktuÃ¡lnÃ­m lokÃ¡lnÃ­m rÃ¡mcem. Na zaÄÃ¡tku interpretace je doÄasnÃ½ rÃ¡mec nedefinovanÃ½.

K pÅ™ekrytÃ½m (dÅ™Ã­ve vloÅ¾enÃ½m) lokÃ¡lnÃ­m rÃ¡mcÅ¯m v zÃ¡sobnÃ­ku rÃ¡mcÅ¯ nelze pÅ™istoupit dÅ™Ã­ve, neÅ¾ vyjmeme pozdÄ›ji pÅ™idanÃ© rÃ¡mce.

DalÅ¡Ã­ moÅ¾nostÃ­ pro uklÃ¡dÃ¡nÃ­ nepojmenovanÃ½ch hodnot je datovÃ½ zÃ¡sobnÃ­k vyuÅ¾Ã­vanÃ½ zÃ¡sobnÃ­kovÃ½mi instrukcemi.

### 10.3 DatovÃ© typy

Interpret IFJcode21 pracuje s typy operandÅ¯ dynamicky, takÅ¾e je typ promÄ›nnÃ© (resp. pamÄ›Å¥ovÃ©ho mÃ­sta) dÃ¡n obsaÅ¾enou hodnotou. NenÃ­-li Å™eÄeno jinak, jsou implicitnÃ­ konverze zakÃ¡zÃ¡ny. Interpret podporuje speciÃ¡lnÃ­ hodnotu/typ nil a ÄtyÅ™i zÃ¡kladnÃ­ datovÃ© typy (int, bool, float a string), jejichÅ¾ rozsahy i pÅ™esnosti jsou kompatibilnÃ­ s jazykem IFJ21.

ZÃ¡pis kaÅ¾dÃ© konstanty v IFJcode21 se sklÃ¡dÃ¡ ze dvou ÄÃ¡stÃ­ oddÄ›lenÃ½ch zavinÃ¡Äem (znak @; bez bÃ­lÃ½ch znakÅ¯), oznaÄenÃ­ typu konstanty (int, bool, float, string, nil) a samotnÃ© konstanty (ÄÃ­slo, literÃ¡l, nil). NapÅ™. _float@0<span>x1.2666666666666p+0</span>_, _bool@true_, _nil@nil_ nebo _int@-5_.

Typ int reprezentuje 64-bitovÃ© celÃ© ÄÃ­slo (rozsah C-long long int). Typ bool reprezentuje pravdivostnÃ­ hodnotu (true nebo false). Typ float popisuje desetinnÃ© ÄÃ­slo (rozsah C-double) a v pÅ™Ã­padÄ› zÃ¡pisu konstant pouÅ¾Ã­vejte v jazyce C formÃ¡tovacÃ­ Å™etÄ›zec '%a' pro funkci `printf`. LiterÃ¡l pro typ string je v pÅ™Ã­padÄ› konstanty zapsÃ¡n jako sekvence tisknutelnÃ½ch ASCII znakÅ¯ (vyjma bÃ­lÃ½ch znakÅ¯, mÅ™Ã­Å¾ky (#) a zpÄ›tnÃ©ho lomÃ­tka (\)) a escape sekvencÃ­, takÅ¾e nenÃ­ ohraniÄen uvozovkami. Escape sekvence, kterÃ¡ je nezbytnÃ¡ pro znaky s ASCII kÃ³dem 000-032, 035 a 092, je tvaru \ğ‘¥ğ‘¦ğ‘§, kde ğ‘¥ğ‘¦ğ‘§ je dekadickÃ© ÄÃ­slo v rozmezÃ­ 000-255 sloÅ¾enÃ© prÃ¡vÄ› ze tÅ™Ã­ ÄÃ­slic; napÅ™. konstanta  
`string@retezec\032s\032lomitkem\032\092\032a\010novym\035radkem`

reprezentuje Å™etÄ›zec  
```
retezec s lomitkem \ a
novym#radkem
```

Pokus o prÃ¡ci s neexistujÃ­cÃ­ promÄ›nnou (ÄtenÃ­ nebo zÃ¡pis) vede na chybu 54. Pokus o ÄtenÃ­ hodnoty neinicializovanÃ© promÄ›nnÃ© vede na chybu 56. Pokus o interpretaci instrukce s operandy nevhodnÃ½ch typÅ¯ dle popisu danÃ© instrukce vede na chybu 53.

### 10.4 InstrukÄnÃ­ sada

U popisu instrukcÃ­ sÃ¡zÃ­me operaÄnÃ­ kÃ³d tuÄnÄ› a operandy zapisujeme pomocÃ­ neterminÃ¡lnÃ­ch symbolÅ¯ (pÅ™Ã­padnÄ› ÄÃ­slovanÃ½ch) v ÃºhlovÃ½ch zÃ¡vorkÃ¡ch. NeterminÃ¡l âŸ¨varâŸ© znaÄÃ­ promÄ›nnou, âŸ¨symbâŸ© konstantu nebo promÄ›nnou, âŸ¨labelâŸ© znaÄÃ­ nÃ¡vÄ›Å¡tÃ­. IdentifikÃ¡tor promÄ›nnÃ© se sklÃ¡dÃ¡ ze dvou ÄÃ¡stÃ­ oddÄ›lenÃ½ch zavinÃ¡Äem (znak @; bez bÃ­lÃ½ch znakÅ¯), oznaÄenÃ­ rÃ¡mce LF, TF nebo GF a samotnÃ©ho jmÃ©na promÄ›nnÃ© (sekvence libovolnÃ½ch alfanumerickÃ½ch a speciÃ¡lnÃ­ch znakÅ¯ bez bÃ­lÃ½ch znakÅ¯ zaÄÃ­najÃ­cÃ­ pÃ­smenem nebo speciÃ¡lnÃ­m znakem, kde speciÃ¡lnÃ­ znaky jsou: \_, -, $, &, %, *, !, ?). NapÅ™. GF@\_x znaÄÃ­ promÄ›nnou \_x uloÅ¾enou v globÃ¡lnÃ­m rÃ¡mci.

Na zÃ¡pis nÃ¡vÄ›Å¡tÃ­ se vztahujÃ­ stejnÃ¡ pravidla jako na jmÃ©no promÄ›nnÃ© (tj. ÄÃ¡st identifikÃ¡toru za zavinÃ¡Äem).

InstrukÄnÃ­ sada nabÃ­zÃ­ instrukce pro prÃ¡ci s promÄ›nnÃ½mi v rÃ¡mcÃ­ch, rÅ¯znÃ© skoky, operace s datovÃ½m zÃ¡sobnÃ­kem, aritmetickÃ©, Å™etÄ›zcovÃ©, logickÃ© a relaÄnÃ­ operace, dÃ¡le takÃ© konverznÃ­, vstupnÄ›/vÃ½stupnÃ­ a ladicÃ­ instrukce.

#### 10.4.1 PrÃ¡ce s rÃ¡mci, volÃ¡nÃ­ funkcÃ­

_PÅ™iÅ™azenÃ­ hodnoty do promÄ›nnÃ©_  
`MOVE âŸ¨varâŸ© âŸ¨symbâŸ©`  
ZkopÃ­ruje hodnotu âŸ¨symbâŸ© do âŸ¨varâŸ©. NapÅ™. `MOVE LF@par GF@var` provede zkopÃ­rovÃ¡nÃ­ hodnoty promÄ›nnÃ© `var` v globÃ¡lnÃ­m rÃ¡mci do promÄ›nnÃ© `par` v lokÃ¡lnÃ­m rÃ¡mci.
___  
_VytvoÅ™ novÃ½ doÄasnÃ½ rÃ¡mec_  
`CREATEFRAME`  
VytvoÅ™Ã­ novÃ½ doÄasnÃ½ rÃ¡mec a zahodÃ­ pÅ™Ã­padnÃ½ obsah pÅ¯vodnÃ­ho doÄasnÃ©ho rÃ¡mce.
___  
_PÅ™esun doÄasnÃ©ho rÃ¡mce na zÃ¡sobnÃ­k rÃ¡mcÅ¯_  
`PUSHFRAME`  
PÅ™esuÅˆ TF na zÃ¡sobnÃ­k rÃ¡mcÅ¯. RÃ¡mec bude k dispozici pÅ™es LF a pÅ™ekryje pÅ¯vodnÃ­ rÃ¡mce na zÃ¡sobnÃ­ku rÃ¡mcÅ¯. TF bude po provedenÃ­ instrukce nedefinovÃ¡n a je tÅ™eba jej pÅ™ed dalÅ¡Ã­m pouÅ¾itÃ­m vytvoÅ™it pomocÃ­ CREATEFRAME. Pokus o pÅ™Ã­stup k nedefinovanÃ©mu rÃ¡mci vede na chybu 55.
___
_PÅ™esun aktuÃ¡lnÃ­ho rÃ¡mce do doÄasnÃ©ho_  
`POPFRAME`  
PÅ™esuÅˆ vrcholovÃ½ rÃ¡mec LF ze zÃ¡sobnÃ­ku rÃ¡mcÅ¯ do TF. Pokud Å¾Ã¡dnÃ½ rÃ¡mec v LF nenÃ­ k dispozici, dojde k chybÄ› 55.
___  
_Definuj novou promÄ›nnou v rÃ¡mci_  
`DEFVAR âŸ¨varâŸ©`  
Definuje promÄ›nnou v urÄenÃ©m rÃ¡mci dle âŸ¨varâŸ©. Tato promÄ›nnÃ¡ je zatÃ­m neinicializovanÃ¡ a bez urÄenÃ­ typu, kterÃ½ bude urÄen aÅ¾ pÅ™iÅ™azenÃ­m nÄ›jakÃ© hodnoty.
___  
_Skok na nÃ¡vÄ›Å¡tÃ­ s podporou nÃ¡vratu_  
`CALL âŸ¨labelâŸ©`  
UloÅ¾Ã­ inkrementovanou aktuÃ¡lnÃ­ pozici z internÃ­ho ÄÃ­taÄe instrukcÃ­ do zÃ¡sobnÃ­ku volÃ¡nÃ­ a provede skok na zadanÃ© nÃ¡vÄ›Å¡tÃ­ (pÅ™Ã­padnou pÅ™Ã­pravu rÃ¡mce musÃ­ zajistit jinÃ© instrukce).
___  
_NÃ¡vrat na pozici uloÅ¾enou instrukcÃ­ CALL_  
`RETURN`  
Vyjme pozici ze zÃ¡sobnÃ­ku volÃ¡nÃ­ a skoÄÃ­ na tuto pozici nastavenÃ­m internÃ­ho ÄÃ­taÄe instrukcÃ­ (Ãºklid lokÃ¡lnÃ­ch rÃ¡mcÅ¯ musÃ­ zajistit jinÃ© instrukce). ProvedenÃ­ instrukce pÅ™i prÃ¡zdnÃ©m zÃ¡sobnÃ­ku volÃ¡nÃ­ vede na chybu 56.

#### 10.4.2 PrÃ¡ce s datovÃ½m zÃ¡sobnÃ­kem

OperaÄnÃ­ kÃ³d zÃ¡sobnÃ­kovÃ½ch instrukcÃ­ je zakonÄen pÃ­smenem â€Sâ€œ. ZÃ¡sobnÃ­kovÃ© instrukce naÄÃ­tajÃ­ chybÄ›jÃ­cÃ­ operandy z datovÃ©ho zÃ¡sobnÃ­ku a vÃ½slednou hodnotu operace uklÃ¡dajÃ­ zpÄ›t na datovÃ½ zÃ¡sobnÃ­k.

_VloÅ¾ hodnotu na vrchol datovÃ©ho zÃ¡sobnÃ­ku_  
`PUSHS âŸ¨symbâŸ©`  
UloÅ¾Ã­ hodnotu âŸ¨symbâŸ© na datovÃ½ zÃ¡sobnÃ­k.
___
_Vyjmi hodnotu z vrcholu datovÃ©ho zÃ¡sobnÃ­ku_  
`POPS âŸ¨varâŸ©`  
NenÃ­-li zÃ¡sobnÃ­k prÃ¡zdnÃ½, vyjme z nÄ›j hodnotu a uloÅ¾Ã­ ji do promÄ›nnÃ© âŸ¨varâŸ©, jinak dojde k chybÄ› 56.
___
_VymazÃ¡nÃ­ obsahu celÃ©ho datovÃ©ho zÃ¡sobnÃ­ku_  
`CLEARS`  
PomocnÃ¡ instrukce, kterÃ¡ smaÅ¾e celÃ½ obsah datovÃ©ho zÃ¡sobnÃ­ku, aby neobsahoval zapomenutÃ© hodnoty z pÅ™edchozÃ­ch vÃ½poÄtÅ¯.
___

#### 10.4.3 AritmetickÃ©, relaÄnÃ­, booleovskÃ© a konverznÃ­ instrukce

V tÃ©to sekci jsou popsÃ¡ny tÅ™Ã­adresnÃ© i zÃ¡sobnÃ­kovÃ© verze instrukcÃ­ pro klasickÃ© operace pro vÃ½poÄet vÃ½razu. ZÃ¡sobnÃ­kovÃ© verze instrukcÃ­ z datovÃ©ho zÃ¡sobnÃ­ku vybÃ­rajÃ­ operandy se vstupnÃ­mi hodnotami dle popisu tÅ™Ã­adresnÃ© instrukce od konce (tj. typicky nejprve âŸ¨symb<sub>2</sub>âŸ© a potÃ© âŸ¨symb<sub>1</sub>âŸ©).

_SouÄet dvou ÄÃ­selnÃ½ch hodnot_  
`ADD âŸ¨varâŸ© âŸ¨symb1âŸ© âŸ¨symb2âŸ©`  
SeÄte âŸ¨symb1âŸ© a âŸ¨symb2âŸ© (musÃ­ bÃ½t stejnÃ©ho ÄÃ­selnÃ©ho typu int nebo float) a vÃ½slednou hodnotu tÃ©hoÅ¾ typu uloÅ¾Ã­ do promÄ›nnÃ© âŸ¨varâŸ©.
___  
_OdeÄÃ­tÃ¡nÃ­ dvou ÄÃ­selnÃ½ch hodnot_  
`SUB âŸ¨varâŸ© âŸ¨symb1âŸ© âŸ¨symb2âŸ©`  
OdeÄte âŸ¨symb2âŸ© od âŸ¨symb1âŸ©(musÃ­ bÃ½t stejnÃ©ho ÄÃ­selnÃ©ho typu int nebo float) a vÃ½slednou hodnotu tÃ©hoÅ¾ typu uloÅ¾Ã­ do promÄ›nnÃ© âŸ¨varâŸ©.
___  
_NÃ¡sobenÃ­ dvou ÄÃ­selnÃ½ch hodnot_  
`MUL âŸ¨varâŸ© âŸ¨symb1âŸ© âŸ¨symb2âŸ©` 
VynÃ¡sobÃ­ âŸ¨symb1âŸ© a âŸ¨symb2âŸ© (musÃ­ bÃ½t stejnÃ©ho ÄÃ­selnÃ©ho typu int nebo float) a vÃ½slednou hodnotu tÃ©hoÅ¾ typu uloÅ¾Ã­ do promÄ›nnÃ© âŸ¨varâŸ©.
___  
_DÄ›lenÃ­ dvou desetinnÃ½ch hodnot_  
`DIV âŸ¨varâŸ© âŸ¨symb1âŸ© âŸ¨symb2âŸ©`   
PodÄ›lÃ­ hodnotu ze âŸ¨symb1âŸ© druhou hodnotou ze âŸ¨symb2âŸ© (oba musÃ­ bÃ½t typu float) a vÃ½sledek pÅ™iÅ™adÃ­ do promÄ›nnÃ© âŸ¨varâŸ© (tÃ©Å¾ typu float). DÄ›lenÃ­ nulou zpÅ¯sobÃ­ chybu 57.
___  
_DÄ›lenÃ­ dvou celoÄÃ­selnÃ½ch hodnot_  
`IDIV âŸ¨varâŸ© âŸ¨symb1âŸ© âŸ¨symb2âŸ©`   
CeloÄÃ­selnÄ› podÄ›lÃ­ hodnotu ze âŸ¨symb1âŸ© druhou hodnotou ze âŸ¨symb2âŸ© (musÃ­ bÃ½t oba typu int) a vÃ½sledek pÅ™iÅ™adÃ­ do promÄ›nnÃ© âŸ¨varâŸ© typu int. DÄ›lenÃ­ nulou zpÅ¯sobÃ­ chybu 57.
___
_ZÃ¡sobnÃ­kovÃ© verze instrukcÃ­ ADD, SUB, MUL, DIV a IDIV_  
`ADDS/SUBS/MULS/DIVS/IDIVS`
___  
_RelaÄnÃ­ operÃ¡tory menÅ¡Ã­, vÄ›tÅ¡Ã­, rovno_  
`LT/GT/EQ âŸ¨varâŸ© âŸ¨symb1âŸ© âŸ¨symb2âŸ©`  
Instrukce vyhodnotÃ­ relaÄnÃ­ operÃ¡tor mezi âŸ¨symb1âŸ© a âŸ¨symb2âŸ© (stejnÃ©ho typu; int, bool, float nebo string) a do booleovskÃ© promÄ›nnÃ© âŸ¨varâŸ© zapÃ­Å¡e false pÅ™i neplatnosti nebo true v pÅ™Ã­padÄ› platnosti odpovÃ­dajÃ­cÃ­ relace. Å˜etÄ›zce jsou porovnÃ¡vÃ¡ny lexikograficky a false je menÅ¡Ã­ neÅ¾ true. Pro vÃ½poÄet neostrÃ½ch nerovnostÃ­ lze pouÅ¾Ã­t AND/OR/NOT. S operandem typu nil (druhÃ½ operand je libovolnÃ©ho typu) lze porovnÃ¡vat pouze instrukcÃ­ EQ, jinak chyba 53.
___  
_ZÃ¡sobnÃ­kovÃ¡ verze instrukcÃ­ LT/GT/EQ_  
`LTS/GTS/EQS`
___  
_ZÃ¡kladnÃ­ booleovskÃ© operÃ¡tory_  
`AND/OR/NOT âŸ¨varâŸ© âŸ¨symb1âŸ© âŸ¨symb2âŸ©`  
Aplikuje konjunkci (logickÃ© A)/disjunkci (logickÃ© NEBO) na operandy typu bool âŸ¨symb1âŸ© a âŸ¨symb2âŸ© nebo negaci na âŸ¨symb1âŸ© (NOT mÃ¡ pouze 2 operandy) a vÃ½sledek
typu bool zapÃ­Å¡e do âŸ¨varâŸ©.
___  
_ZÃ¡sobnÃ­kovÃ¡ verze instrukcÃ­ AND, OR a NOT_  
`ANDS/ORS/NOTS`  
___  
_PÅ™evod celoÄÃ­selnÃ© hodnoty na desetinnou_  
`INT2FLOAT âŸ¨varâŸ© âŸ¨symbâŸ©`   
PÅ™evede celoÄÃ­selnou hodnotu âŸ¨symbâŸ© na desetinnÃ© ÄÃ­slo a uloÅ¾Ã­ je do âŸ¨varâŸ©.
___  
_PÅ™evod desetinnÃ© hodnoty na celoÄÃ­selnou (oseknutÃ­)_  
`FLOAT2INT âŸ¨varâŸ© âŸ¨symbâŸ©`  
PÅ™evede desetinnou hodnotu âŸ¨symbâŸ© na celoÄÃ­selnou oseknutÃ­m desetinnÃ© ÄÃ¡sti a uloÅ¾Ã­ ji do âŸ¨varâŸ©.
___
_PÅ™evod celÃ©ho ÄÃ­sla na znak_  
`INT2CHAR âŸ¨varâŸ© âŸ¨symbâŸ©`  
ÄŒÃ­selnÃ¡ hodnota âŸ¨symbâŸ© je dle ASCII pÅ™evedena na znak, kterÃ½ tvoÅ™Ã­ jednoznakovÃ½ Å™etÄ›zec pÅ™iÅ™azenÃ½ do âŸ¨varâŸ©. Je-li âŸ¨symbâŸ© mimo interval [0; 255], dojde k chybÄ› 58.
___  
_OrdinÃ¡lnÃ­ hodnota znaku_  
`STRI2INT âŸ¨varâŸ© âŸ¨symb1âŸ© âŸ¨symb2âŸ©`  
Do âŸ¨varâŸ© uloÅ¾Ã­ ordinÃ¡lnÃ­ hodnotu znaku (dle ASCII) v Å™etÄ›zci âŸ¨symb1âŸ© na pozici âŸ¨symb2âŸ© (indexovÃ¡no od nuly). Indexace mimo danÃ½ Å™etÄ›zec vede na chybu 58.
___  
_ZÃ¡sobnÃ­kovÃ© verze konverznÃ­ch instrukcÃ­_  
`INT2FLOATS/FLOAT2INTS/INT2CHARS/STRI2INTS`
___

#### 10.4.4 VstupnÄ›-vÃ½stupnÃ­ instrukce

_NaÄtenÃ­ hodnoty ze standardnÃ­ho vstupu_  
`READ âŸ¨varâŸ© âŸ¨typeâŸ©`  
NaÄte jednu hodnotu dle zadanÃ©ho typu âŸ¨typeâŸ©âˆˆ {int, float, string, bool}(vÄetnÄ› pÅ™Ã­padnÃ© konverze vstupnÃ­ hodnoty float pÅ™i zadanÃ©m typu int) a uloÅ¾Ã­ tuto hodnotu do promÄ›nnÃ© âŸ¨varâŸ©. FormÃ¡t hodnot je kompatibilnÃ­ s chovÃ¡nÃ­m vestavÄ›nÃ½ch funkcÃ­ reads, readi a readn jazyka IFJ21.
___  
_VÃ½pis hodnoty na standardnÃ­ vÃ½stup_  
`WRITE âŸ¨symbâŸ©`  
VypÃ­Å¡e hodnotu âŸ¨symbâŸ© na standardnÃ­ vÃ½stup. FormÃ¡t vÃ½pisu je kompatibilnÃ­ s vestavÄ›nÃ½m pÅ™Ã­kazem write jazyka IFJ21 vÄetnÄ› vÃ½pisu desetinnÃ½ch ÄÃ­sel pomocÃ­ formÃ¡tovacÃ­ho Å™etÄ›zce â€%aâ€.
___  

#### 10.4.5 PrÃ¡ce s Å™etÄ›zci

_Konkatenace dvou Å™etÄ›zcÅ¯_  
`CONCAT âŸ¨varâŸ© âŸ¨symb1âŸ© âŸ¨symb2âŸ©`  
Do promÄ›nnÃ© âŸ¨varâŸ© uloÅ¾Ã­ Å™etÄ›zec vzniklÃ½ konkatenacÃ­ dvou Å™etÄ›zcovÃ½ch operandÅ¯ âŸ¨symb1âŸ© a âŸ¨symb2âŸ© (jinÃ© typy nejsou povoleny).
___  
_Zjisti dÃ©lku Å™etÄ›zce_  
`STRLEN âŸ¨varâŸ© âŸ¨symbâŸ©`  
ZjistÃ­ dÃ©lku Å™etÄ›zce v âŸ¨symbâŸ© a dÃ©lka je uloÅ¾ena jako celÃ© ÄÃ­slo do âŸ¨varâŸ©.
___  
_VraÅ¥ znak Å™etÄ›zce_  
`GETCHAR âŸ¨varâŸ© âŸ¨symb1âŸ© âŸ¨symb2âŸ©`   
Do âŸ¨varâŸ© uloÅ¾Ã­ Å™etÄ›zec z jednoho znaku v Å™etÄ›zci âŸ¨symb1âŸ© na pozici âŸ¨symb2âŸ© (indexovÃ¡no celÃ½m ÄÃ­slem od nuly). Indexace mimo danÃ½ Å™etÄ›zec vede na chybu 58.
___  
_ZmÄ›Åˆ znak Å™etÄ›zce_  
`SETCHAR âŸ¨varâŸ© âŸ¨symb1âŸ© âŸ¨symb2âŸ©`  
Zmodifikuje znak Å™etÄ›zce uloÅ¾enÃ©ho v promÄ›nnÃ© âŸ¨varâŸ© na pozici âŸ¨symb1âŸ© (indexovÃ¡no celoÄÃ­selnÄ› od nuly) na znak v Å™etÄ›zci âŸ¨symb2âŸ© (prvnÃ­ znak, pokud obsahuje âŸ¨symb2âŸ© vÃ­ce znakÅ¯). VÃ½slednÃ½ Å™etÄ›zec je opÄ›t uloÅ¾en do âŸ¨varâŸ©. PÅ™i indexaci mimo Å™etÄ›zec âŸ¨varâŸ© nebo v pÅ™Ã­padÄ› prÃ¡zdnÃ©ho Å™etÄ›zce v âŸ¨symb2âŸ© dojde k chybÄ› 58.
___

#### 10.4.6 PrÃ¡ce s typy

_Zjisti typ danÃ©ho symbolu_  
`TYPE âŸ¨varâŸ© âŸ¨symbâŸ©`  
Dynamicky zjistÃ­ typ symbolu âŸ¨symbâŸ© a do âŸ¨varâŸ© zapÃ­Å¡e Å™etÄ›zec znaÄÃ­cÃ­ tento typ (int, bool, float, string nebo nil). Je-li âŸ¨symbâŸ© neinicializovanÃ¡ promÄ›nnÃ¡, oznaÄÃ­ jejÃ­ typ prÃ¡zdnÃ½m Å™etÄ›zcem.
___  

#### 10.4.7 Instrukce pro Å™Ã­zenÃ­ toku programu
NeterminÃ¡l âŸ¨labelâŸ© oznaÄuje nÃ¡vÄ›Å¡tÃ­, kterÃ© slouÅ¾Ã­ pro oznaÄenÃ­ pozice v kÃ³du IFJcode21. V pÅ™Ã­padÄ› skoku na neexistujÃ­cÃ­ nÃ¡vÄ›Å¡tÃ­ dojde k chybÄ› 52.  

_Definice nÃ¡vÄ›Å¡tÃ­_  
`LABEL âŸ¨labelâŸ©`  
SpeciÃ¡lnÃ­ instrukce oznaÄujÃ­cÃ­ pomocÃ­ nÃ¡vÄ›Å¡tÃ­ âŸ¨labelâŸ© dÅ¯leÅ¾itou pozici v kÃ³du jako potenciÃ¡lnÃ­ cÃ­l libovolnÃ© skokovÃ© instrukce. Pokus o redefinici existujÃ­cÃ­ho nÃ¡vÄ›Å¡tÃ­ je chybou 52.
___  
_NepodmÃ­nÄ›nÃ½ skok na nÃ¡vÄ›Å¡tÃ­_  
`JUMP âŸ¨labelâŸ©`  
Provede nepodmÃ­nÄ›nÃ½ skok na zadanÃ© nÃ¡vÄ›Å¡tÃ­ âŸ¨labelâŸ©.
___  
_PodmÃ­nÄ›nÃ½ skok na nÃ¡vÄ›Å¡tÃ­ pÅ™i rovnosti_  
`JUMPIFEQ âŸ¨labelâŸ© âŸ¨symb1âŸ© âŸ¨symb2âŸ©`  
Pokud jsou âŸ¨symb1âŸ© a âŸ¨symb2âŸ© stejnÃ©ho typu nebo je nÄ›kterÃ½ operand nil (jinak chyba 53) a zÃ¡roveÅˆ se jejich hodnoty rovnajÃ­, tak provede skok na nÃ¡vÄ›Å¡tÃ­ âŸ¨labelâŸ©.
___  
_PodmÃ­nÄ›nÃ½ skok na nÃ¡vÄ›Å¡tÃ­ pÅ™i nerovnosti_  
`JUMPIFNEQ âŸ¨labelâŸ© âŸ¨symb1âŸ© âŸ¨symb2âŸ©`  
Jsou-li âŸ¨symb1âŸ© a âŸ¨symb2âŸ© stejnÃ©ho typu nebo je nÄ›kterÃ½ operand nil (jinak chyba 53), ale rÅ¯znÃ© hodnoty, tak provede skok na nÃ¡vÄ›Å¡tÃ­ âŸ¨labelâŸ©.
___  
_ZÃ¡sobnÃ­kovÃ¡ verze JUMPIFEQ, JUMPIFNEQ_  
`JUMPIFEQS/JUMPIFNEQS âŸ¨labelâŸ©`  
ZÃ¡sobnÃ­kovÃ© skokovÃ© instrukce majÃ­ i jeden operand mimo datovÃ½ zÃ¡sobnÃ­k, a to nÃ¡vÄ›Å¡tÃ­ âŸ¨labelâŸ©, na kterÃ© se pÅ™Ã­padnÄ› provede skok.
___  
_UkonÄenÃ­ interpretace s nÃ¡vratovÃ½m kÃ³dem_  
`EXIT âŸ¨symbâŸ©`  
UkonÄÃ­ vykonÃ¡vÃ¡nÃ­ programu a ukonÄÃ­ interpret s nÃ¡vratovÃ½m kÃ³dem âŸ¨symbâŸ©, kde âŸ¨symbâŸ© je celÃ© ÄÃ­slo v intervalu 0 aÅ¾ 49 (vÄetnÄ›). NevalidnÃ­ celoÄÃ­selnÃ¡ hodnota âŸ¨symbâŸ© vede na chybu 57.
___  

#### 10.4.8 LadicÃ­ instrukce

_VÃ½pis stavu interpretu na stderr_  
`BREAK` 
Na standardnÃ­ chybovÃ½ vÃ½stup (stderr) vypÃ­Å¡e stav interpretu v danou chvÃ­li (tj. bÄ›hem vykonÃ¡vÃ¡nÃ­ tÃ©to instrukce). Stav se mimo jinÃ© sklÃ¡dÃ¡ z pozice v kÃ³du, vÃ½pisu globÃ¡lnÃ­ho, aktuÃ¡lnÃ­ho lokÃ¡lnÃ­ho a doÄasnÃ©ho rÃ¡mce a poÄtu jiÅ¾ vykonanÃ½ch instrukcÃ­.
___  
_VÃ½pis hodnoty na stderr_  
`DPRINT âŸ¨symbâŸ©`  
VypÃ­Å¡e zadanou hodnotu âŸ¨symbâŸ© na standardnÃ­ chybovÃ½ vÃ½stup (stderr). VÃ½pisy touto instrukcÃ­ bude moÅ¾nÃ© vypnout pomocÃ­ volby interpretu (viz nÃ¡povÄ›da interpretu).
___  

## 11 Pokyny ke zpÅ¯sobu vypracovÃ¡nÃ­ a odevzdÃ¡nÃ­

Tyto dÅ¯leÅ¾itÃ© informace nepodceÅˆujte, neboÅ¥ projekty bude ÄÃ¡steÄnÄ› opravovat automat a nedodrÅ¾enÃ­ tÄ›chto pokynÅ¯ povede k tomu, Å¾e automat danÃ½ projekt nebude schopen pÅ™eloÅ¾it, zpracovat a ohodnotit, coÅ¾ mÅ¯Å¾e vÃ©st aÅ¾ ke ztrÃ¡tÄ› vÅ¡ech bodÅ¯ z projektu!

### 11.1 ObecnÃ© informace

Za celÃ½ tÃ½m odevzdÃ¡ projekt jedinÃ½ student. VÅ¡echny odevzdanÃ© soubory budou zkomprimovÃ¡ny programem ZIP, TAR+GZIP, nebo TAR+BZIP do jedinÃ©ho archivu, kterÃ½ se bude jmenovat xlogin99.zip, xlogin99.tgz, nebo xlogin99.tbz, kde mÃ­sto zÃ¡stupnÃ©ho Å™etÄ›zce xlogin99 pouÅ¾ijte Å¡kolnÃ­ pÅ™ihlaÅ¡ovacÃ­ jmÃ©no vedoucÃ­ho tÃ½mu. Archiv nesmÃ­ obsahovat adresÃ¡Å™ovou strukturu ani speciÃ¡lnÃ­ Äi spustitelnÃ© soubory. NÃ¡zvy vÅ¡ech souborÅ¯ budou obsahovat pouze pÃ­smena20, ÄÃ­slice, teÄku a podtrÅ¾Ã­tko (ne mezery!).

CelÃ½ projekt je tÅ™eba odevzdat v danÃ©m termÃ­nu (viz vÃ½Å¡e). Pokud tomu tak nebude, je projekt povaÅ¾ovÃ¡n za neodevzdanÃ½. StejnÄ› tak, pokud se bude jednat o plagiÃ¡torstvÃ­ jakÃ©hokoliv druhu, je projekt hodnocenÃ½ nula body, navÃ­c v IFJ ani v IAL nebude udÄ›len zÃ¡poÄet a bude zvÃ¡Å¾eno zahÃ¡jenÃ­ disciplinÃ¡rnÃ­ho Å™Ã­zenÃ­.

VÅ¾dy platÃ­, Å¾e je tÅ™eba pÅ™i Å™eÅ¡enÃ­ problÃ©mÅ¯ aktivnÄ› a konstruktivnÄ› komunikovat nejen uvnitÅ™ tÃ½mu, ale obÄas i se cviÄÃ­cÃ­m. PÅ™i komunikaci uvÃ¡dÄ›jte login vedoucÃ­ho a ÄÃ­slo tÃ½mu.

### 11.2 DÄ›lenÃ­ bodÅ¯

OdevzdanÃ½ archÃ­v bude povinnÄ› obsahovat soubor `rozdeleni`, ve kterÃ©m zohlednÃ­te dÄ›lenÃ­ bodÅ¯ mezi jednotlivÃ© Äleny tÃ½mu (i pÅ™i poÅ¾adavku na rovnomÄ›rnÃ© dÄ›lenÃ­). Na kaÅ¾dÃ©m Å™Ã¡dku je uveden login jednoho Älena tÃ½mu, bez mezery je nÃ¡sledovÃ¡n dvojteÄkou a po nÃ­ je bez mezery uveden poÅ¾adovanÃ½ celoÄÃ­selnÃ½ poÄet procent bodÅ¯ bez uvedenÃ­ znaku %. KaÅ¾dÃ½ Å™Ã¡dek (i poslednÃ­) je potÃ© ihned ukonÄen jednÃ­m znakem âŸ¨LFâŸ© (ASCII hodnota 10, tj. unixovÃ© ukonÄenÃ­ Å™Ã¡dku, ne windowsovskÃ©!). Obsah souboru bude vypadat napÅ™Ã­klad takto (`(LF)` zastupuje unixovÃ© odÅ™Ã¡dkovÃ¡nÃ­):
```
xnovak01:30(LF)
xnovak02:40(LF)
xnovak03:30(LF)
xnovak04:00(LF)
```

SouÄet vÅ¡ech procent musÃ­ bÃ½t roven 100. V pÅ™Ã­padÄ› chybnÃ©ho celkovÃ©ho souÄtu vÅ¡ech procent bude pouÅ¾ito rovnomÄ›rnÃ© rozdÄ›lenÃ­. FormÃ¡t odevzdanÃ©ho souboru musÃ­ bÃ½t
sprÃ¡vnÃ½ a obsahovat vÅ¡echny registrovanÃ© Äleny tÃ½mu (i ty hodnocenÃ© 0 %).

VedoucÃ­ tÃ½mu je pÅ™ed odevzdÃ¡nÃ­m projektu povinen celÃ½ tÃ½m informovat o rozdÄ›lenÃ­ bodÅ¯. KaÅ¾dÃ½ Älen tÃ½mu je navÃ­c povinen rozdÄ›lenÃ­ bodÅ¯ zkontrolovat po odevzdÃ¡nÃ­ do IS FIT a pÅ™Ã­padnÄ› rozdÄ›lenÃ­ bodÅ¯ reklamovat u cviÄÃ­cÃ­ho jeÅ¡tÄ› pÅ™ed obhajobou projektu.

## 12 PoÅ¾adavky na Å™eÅ¡enÃ­

KromÄ› poÅ¾adavkÅ¯ na implementaci a dokumentaci obsahuje tato kapitola i nÄ›kolik rad pro zdÃ¡rnÃ© Å™eÅ¡enÃ­ tohoto projektu a vÃ½Äet rozÅ¡Ã­Å™enÃ­ za prÃ©miovÃ© body.

### 12.1 ZÃ¡vaznÃ© metody pro implementaci pÅ™ekladaÄe 

Projekt bude hodnocen pouze jako funkÄnÃ­ celek, a nikoli jako soubor separÃ¡tnÃ­ch, spoleÄnÄ› nekooperujÃ­cÃ­ch modulÅ¯. PÅ™i tvorbÄ› lexikÃ¡lnÃ­ analÃ½zy vyuÅ¾ijete znalosti koneÄnÃ½ch automatÅ¯. PÅ™i konstrukci syntaktickÃ© analÃ½zy zaloÅ¾enÃ© na LL-gramatice (vÅ¡e kromÄ› vÃ½razÅ¯) povinnÄ› vyuÅ¾ijte buÄ metodu rekurzivnÃ­ho sestupu (doporuÄeno), nebo prediktivnÃ­ analÃ½zu Å™Ã­zenou LL-tabulkou. VÃ½razy zpracujte pouze pomocÃ­ precedenÄnÃ­ syntaktickÃ© analÃ½zy. VÅ¡e bude probÃ­rÃ¡no na pÅ™ednÃ¡Å¡kÃ¡ch v rÃ¡mci pÅ™edmÄ›tu IFJ. Implementace bude provedena v jazyce C, ÄÃ­mÅ¾ ÃºmyslnÄ› omezujeme moÅ¾nosti pouÅ¾itÃ­ objektovÄ› orientovanÃ© implementace. NÃ¡vrh implementace pÅ™ekladaÄe je zcela v reÅ¾ii Å™eÅ¡itelskÃ½ch tÃ½mÅ¯. NenÃ­ dovoleno spouÅ¡tÄ›t dalÅ¡Ã­ procesy a vytvÃ¡Å™et novÃ© Äi modifikovat existujÃ­cÃ­ soubory (ani v adresÃ¡Å™i /tmp). NedodrÅ¾enÃ­ tÄ›chto metod bude penalizovÃ¡no znaÄnou ztrÃ¡tou bodÅ¯! 

### 12.2 Implementace tabulky symbolÅ¯ v souboru symtable.c

Implementaci tabulky symbolÅ¯ (dle varianty zadÃ¡nÃ­) proveÄte dle pÅ™Ã­stupÅ¯ probÃ­ranÃ½ch v pÅ™edmÄ›tu IAL a umÃ­stÄ›te ji do souboru symtable.c. Pokud se rozhodnete o odliÅ¡nÃ½ zpÅ¯sob implementace, vysvÄ›tlete v dokumentaci dÅ¯vody, kterÃ© vÃ¡s k tomu vedly, a uveÄte zdroje, ze kterÃ½ch jste Äerpali.

### 12.3 TextovÃ¡ ÄÃ¡st Å™eÅ¡enÃ­

SouÄÃ¡stÃ­ Å™eÅ¡enÃ­ bude dokumentace vypracovanÃ¡ ve formÃ¡tu PDF a uloÅ¾enÃ¡ v jedinÃ©m souboru dokumentace.pdf. JakÃ½koliv jinÃ½ neÅ¾ pÅ™edepsanÃ½ formÃ¡t dokumentace bude ignorovÃ¡n, coÅ¾ povede ke ztrÃ¡tÄ› bodÅ¯ za dokumentaci. Dokumentace bude vypracovÃ¡na v ÄeskÃ©m, slovenskÃ©m nebo anglickÃ©m jazyce v rozsahu cca. 3-5 stran A4.
V dokumentaci popisujte nÃ¡vrh (ÄÃ¡sti pÅ™ekladaÄe a pÅ™edÃ¡vÃ¡nÃ­ informacÃ­ mezi nimi), implementaci (pouÅ¾itÃ© datovÃ© struktury, tabulku symbolÅ¯, generovÃ¡nÃ­ kÃ³du), vÃ½vojovÃ½ cyklus, zpÅ¯sob prÃ¡ce v tÃ½mu, speciÃ¡lnÃ­ pouÅ¾itÃ© techniky a algoritmy a rÅ¯znÃ© odchylky od pÅ™ednÃ¡Å¡enÃ© lÃ¡tky Äi tradiÄnÃ­ch pÅ™Ã­stupÅ¯. NezapomÃ­nejte takÃ© citovat literaturu a uvÃ¡dÄ›t reference na ÄerpanÃ© zdroje vÄetnÄ› sprÃ¡vnÃ© citace pÅ™evzatÃ½ch ÄÃ¡stÃ­ (obrÃ¡zky, magickÃ© konstanty, vzorce). Nepopisujte zÃ¡leÅ¾itosti obecnÄ› znÃ¡mÃ© Äi pÅ™ednÃ¡Å¡enÃ© na naÅ¡Ã­ fakultÄ›.

Dokumentace musÃ­ povinnÄ› obsahovat (povinnÃ© tabulky a diagramy se nezapoÄÃ­tÃ¡vajÃ­ do doporuÄenÃ©ho rozsahu):
- 1\. strana: jmÃ©na, pÅ™Ã­jmenÃ­ a pÅ™ihlaÅ¡ovacÃ­ jmÃ©na Å™eÅ¡itelÅ¯ (oznaÄenÃ­ vedoucÃ­ho) + Ãºdaje o rozdÄ›lenÃ­ bodÅ¯, identifikaci vaÅ¡Ã­ varianty zadÃ¡nÃ­ ve tvaru â€œTÃ½m ÄÃ­slo, varianta ğ‘‹â€ a vÃ½Äet identifikÃ¡torÅ¯ implementovanÃ½ch rozÅ¡Ã­Å™enÃ­.
- RozdÄ›lenÃ­ prÃ¡ce mezi Äleny tÃ½mu (uveÄte kdo a jak se podÃ­lel na jednotlivÃ½ch ÄÃ¡stech projektu; povinnÄ› zdÅ¯vodnÄ›te odchylky od rovnomÄ›rnÃ©ho rozdÄ›lenÃ­ bodÅ¯).
- Diagram koneÄnÃ©ho automatu, kterÃ½ specifikuje lexikÃ¡lnÃ­ analyzÃ¡tor.
- LL-gramatiku, LL-tabulku a precedenÄnÃ­ tabulku, podle kterÃ½ch jste implementovali vÃ¡Å¡ syntaktickÃ½ analyzÃ¡tor.
- StruÄnÃ½ popis ÄlenÄ›nÃ­ implementaÄnÃ­ho Å™eÅ¡enÃ­ vÄetnÄ› nÃ¡zvÅ¯ souborÅ¯, kde jsou jednotlivÃ© ÄÃ¡sti pÅ™ekladaÄe k nalezenÃ­.

Dokumentace nesmÃ­:
- obsahovat kopii zadÃ¡nÃ­ Äi text, obrÃ¡zky nebo diagramy, kterÃ© nejsou vaÅ¡e pÅ¯vodnÃ­ (kopie z pÅ™ednÃ¡Å¡ek, sÃ­tÄ›, WWW, â€¦).
- bÃ½t zaloÅ¾ena pouze na vÃ½Ätu a obecnÃ©m popisu jednotlivÃ½ch pouÅ¾itÃ½ch metod (jde o vÃ¡Å¡ vlastnÃ­ pÅ™Ã­stup k Å™eÅ¡enÃ­; a proto dokumentujte postup, kterÃ½m jste se pÅ™i Å™eÅ¡enÃ­ ubÃ­rali; pÅ™ekÃ¡Å¾kÃ¡ch, se kterÃ½mi jste se pÅ™i Å™eÅ¡enÃ­ setkali; problÃ©mech, kterÃ© jste Å™eÅ¡ili a jak jste je Å™eÅ¡ili; atd.)

V rÃ¡mci dokumentace bude rovnÄ›Å¾ vzat v Ãºvahu stav kÃ³du jako jeho Äitelnost, srozumitelnost a dostateÄnÃ©, ale nikoli pÅ™ehnanÃ© komentÃ¡Å™e.

### 12.4 ProgramovÃ¡ ÄÃ¡st Å™eÅ¡enÃ­

ProgramovÃ¡ ÄÃ¡st Å™eÅ¡enÃ­ bude vypracovÃ¡na v jazyce C bez pouÅ¾itÃ­ generÃ¡torÅ¯ lex/flex, yacc/bison Äi jinÃ½ch podobnÃ©ho raÅ¾enÃ­ a musÃ­ bÃ½t pÅ™eloÅ¾itelnÃ¡ pÅ™ekladaÄem gcc. PÅ™i hodnocenÃ­ budou projekty pÅ™eklÃ¡dÃ¡ny na Å¡kolnÃ­m serveru merlin. PoÄÃ­tejte tedy s touto skuteÄnostÃ­ (pÅ™edevÅ¡Ã­m, pokud budete projekt psÃ¡t pod jinÃ½m OS). Pokud projekt nepÅ¯jde pÅ™eloÅ¾it Äi nebude sprÃ¡vnÄ› pracovat kvÅ¯li pouÅ¾itÃ­ funkce nebo nÄ›jakÃ© nestandardnÃ­ implementaÄnÃ­ techniky zÃ¡vislÃ© na OS, nebude projekt hodnocenÃ½. Ve spornÃ½ch pÅ™Ã­padech bude vÅ¾dy za platnÃ½ povaÅ¾ovÃ¡n vÃ½sledek pÅ™ekladu a testovÃ¡nÃ­ na serveru merlin bez pouÅ¾itÃ­ jakÃ½chkoliv dodateÄnÃ½ch nastavenÃ­ (promÄ›nnÃ© prostÅ™edÃ­, â€¦).

SouÄÃ¡stÃ­ Å™eÅ¡enÃ­ bude soubor Makefile slouÅ¾Ã­cÃ­ pro pÅ™eklad projektu pomocÃ­ pÅ™Ã­kazu make. Pokud soubor pro sestavenÃ­ cÃ­lovÃ©ho programu nebude obsaÅ¾en nebo se na jeho zÃ¡kladÄ› nepodaÅ™Ã­ sestavit cÃ­lovÃ½ program, nebude projekt hodnocenÃ½! JmÃ©no cÃ­lovÃ©ho programu nenÃ­ rozhodujÃ­cÃ­, bude pÅ™ejmenovÃ¡n automaticky.

BinÃ¡rnÃ­ soubor (pÅ™eloÅ¾enÃ½ pÅ™ekladaÄ) v Å¾Ã¡dnÃ©m pÅ™Ã­padÄ› do archÃ­vu nepÅ™iklÃ¡dejte!

Ãšvod vÅ¡ech zdrojovÃ½ch textÅ¯ musÃ­ obsahovat zakomentovanÃ½ nÃ¡zev projektu, pÅ™ihlaÅ¡ovacÃ­ jmÃ©na a jmÃ©na studentÅ¯, kteÅ™Ã­ se na danÃ©m souboru skuteÄnÄ› autorsky podÃ­leli.

VeÅ¡kerÃ¡ chybovÃ¡ hlÃ¡Å¡enÃ­ vzniklÃ¡ v prÅ¯bÄ›hu Äinnosti pÅ™ekladaÄe budou vÅ¾dy vypisovÃ¡na na standardnÃ­ chybovÃ½ vÃ½stup. VeÅ¡kerÃ© texty tiÅ¡tÄ›nÃ© Å™Ã­dicÃ­m programem budou vypisovÃ¡ny na standardnÃ­ vÃ½stup, pokud nenÃ­ explicitnÄ› Å™eÄeno jinak. KromÄ› chybovÃ½ch/ladicÃ­ch hlÃ¡Å¡enÃ­ vypisovanÃ½ch na standardnÃ­ chybovÃ½ vÃ½stup nebude generovanÃ½ mezikÃ³d pÅ™ikazovat vÃ½pis Å¾Ã¡dnÃ½ch znakÅ¯ Äi dokonce celÃ½ch textÅ¯, kterÃ© nejsou pÅ™Ã­mo pÅ™edepsÃ¡ny Å™Ã­dicÃ­m programem. ZÃ¡kladnÃ­ testovÃ¡nÃ­ bude probÃ­hat pomocÃ­ automatu, kterÃ½ bude postupnÄ› vaÅ¡Ã­m pÅ™ekladaÄem kompilovat sadu testovacÃ­ch pÅ™Ã­kladÅ¯, kompilÃ¡t interpretovat naÅ¡Ã­m interpretem jazyka IFJcode21 a porovnÃ¡vat produkovanÃ© vÃ½stupy na standardnÃ­ vÃ½stup s vÃ½stupy oÄekÃ¡vanÃ½mi. Pro porovnÃ¡nÃ­ vÃ½stupÅ¯ bude pouÅ¾it program diff (viz info diff). Proto jedinÃ½ neoÄekÃ¡vanÃ½ znak, kterÃ½ bude pÅ™i hodnotÃ­cÃ­ interpretaci vÃ¡mi vygenerovanÃ©ho kÃ³du svÃ©volnÄ› vytisknut, povede k nevyhovujÃ­cÃ­mu hodnocenÃ­ aktuÃ¡lnÃ­ho vÃ½stupu, a tÃ­m snÃ­Å¾enÃ­ bodovÃ©ho hodnocenÃ­ celÃ©ho projektu.

### 12.5 Jak postupovat pÅ™i Å™eÅ¡enÃ­ projektu

PÅ™i Å™eÅ¡enÃ­ je pochopitelnÄ› moÅ¾nÃ© vyuÅ¾Ã­t vlastnÃ­ vÃ½poÄetnÃ­ techniku. Instalace pÅ™ekladaÄe gcc nenÃ­ tÅ™eba, pokud mÃ¡te jiÅ¾ instalovanÃ½ jinÃ½ pÅ™ekladaÄ jazyka C, avÅ¡ak nesmÃ­te v tomto pÅ™ekladaÄi vyuÅ¾Ã­vat vlastnosti, kterÃ© gcc nepodporuje. PÅ™ed pouÅ¾itÃ­m nÄ›jakÃ© vyspÄ›lÃ© konstrukce je dobrÃ© si ovÄ›Å™it, Å¾e jÃ­ disponuje i pÅ™ekladaÄ gcc na serveru merlin. Po vypracovÃ¡nÃ­ je tÃ©Å¾ vhodnÃ© vÅ¡e ovÄ›Å™it na serveru Merlin, aby pÅ™i pÅ™ekladu a hodnocenÃ­ projektu vÅ¡e probÄ›hlo bez problÃ©mÅ¯. V Souborech pÅ™edmÄ›tu v IS FIT je k dispozici skript is_it_ok.sh na kontrolu vÄ›tÅ¡iny formÃ¡lnÃ­ch poÅ¾adavkÅ¯ odevzdÃ¡vanÃ©ho archivu, kterÃ½ doporuÄujeme vyuÅ¾Ã­t.

TeoretickÃ© znalosti, potÅ™ebnÃ© pro vytvoÅ™enÃ­ projektu, zÃ­skÃ¡te bÄ›hem semestru na pÅ™ednÃ¡Å¡kÃ¡ch, wiki strÃ¡nkÃ¡ch a diskuznÃ­m fÃ³ru IFJ. Postupuje-li VaÅ¡e realizace projektu rychleji neÅ¾ probÃ­rÃ¡nÃ­ tÃ©mat na pÅ™ednÃ¡Å¡ce, doporuÄujeme vyuÅ¾Ã­t samostudium (viz zveÅ™ejnÄ›nÃ© zÃ¡znamy z minulÃ½ch let a detailnÄ›jÅ¡Ã­ pokyny na wiki strÃ¡nkÃ¡ch IFJ). Je nezbytnÃ©, aby na Å™eÅ¡enÃ­ projektu spolupracoval celÃ½ tÃ½m. NÃ¡vrh pÅ™ekladaÄe, zÃ¡kladnÃ­ch rozhranÃ­ a rozdÄ›lenÃ­ prÃ¡ce lze vytvoÅ™it jiÅ¾ v prvnÃ­ ÄtvrtinÄ› semestru. Je dobrÃ©, kdyÅ¾ se celÃ½ tÃ½m domluvÃ­ na pravidelnÃ½ch schÅ¯zkÃ¡ch a komunikaÄnÃ­ch kanÃ¡lech, kterÃ© bude bÄ›hem Å™eÅ¡enÃ­ projektu vyuÅ¾Ã­vat (instant messaging, video konference, verzovacÃ­ systÃ©m, Å¡tÃ¡bnÃ­ kulturu atd.).

Situaci, kdy je projekt ignorovÃ¡n ÄÃ¡stÃ­ tÃ½mu, lze Å™eÅ¡it prostÅ™ednictvÃ­m souboru rozdeleni a extrÃ©mnÃ­ pÅ™Ã­pady Å™eÅ¡te pÅ™Ã­mo se cviÄÃ­cÃ­mi co nejdÅ™Ã­ve. Je ale nutnÃ©, abyste si vzÃ¡jemnÄ› (nespolÃ©hejte pouze na vedoucÃ­ho), nejlÃ©pe na pravidelnÃ½ch schÅ¯zkÃ¡ch tÃ½mu, ovÄ›Å™ovali skuteÄnÃ½ pokrok v prÃ¡ci na projektu a pÅ™Ã­padnÄ› vÄas pÅ™erozdÄ›lili prÃ¡ci.

MaximÃ¡lnÃ­ poÄet bodÅ¯ zÃ­skatelnÃ½ na jednu osobu za programovou implementaci je 20 vÄetnÄ› bonusovÃ½ch bodÅ¯ za rozÅ¡Ã­Å™enÃ­ projektu.

NenechÃ¡vejte Å™eÅ¡enÃ­ projektu aÅ¾ na poslednÃ­ tÃ½den. Projekt je tvoÅ™en z nÄ›kolika ÄÃ¡stÃ­ (napÅ™. lexikÃ¡lnÃ­ analÃ½za, syntaktickÃ¡ analÃ½za, sÃ©mantickÃ¡ analÃ½za, tabulka symbolÅ¯, generovÃ¡nÃ­ mezikÃ³du, dokumentace, testovÃ¡nÃ­!) a dimenzovÃ¡n tak, aby jednotlivÃ© ÄÃ¡sti bylo moÅ¾no navrhnout a implementovat jiÅ¾ v prÅ¯bÄ›hu semestru na zÃ¡kladÄ› znalostÃ­ zÃ­skanÃ½ch na pÅ™ednÃ¡Å¡kÃ¡ch pÅ™edmÄ›tÅ¯ IFJ a IAL a samostudiem na wiki strÃ¡nkÃ¡ch a diskuznÃ­m fÃ³ru pÅ™edmÄ›tu IFJ.

### 12.6 PokusnÃ© odevzdÃ¡nÃ­

Pro zvÃ½Å¡enÃ­ motivace studentÅ¯ pro vÄasnÃ© vypracovÃ¡nÃ­ projektu nabÃ­zÃ­me koncept nepovinnÃ©ho pokusnÃ©ho odevzdÃ¡nÃ­. VÃ½mÄ›nou za pokusnÃ© odevzdÃ¡nÃ­ do uvedenÃ©ho termÃ­nu (nÄ›kolik tÃ½dnÅ¯ pÅ™ed finÃ¡lnÃ­m termÃ­nem) dostanete zpÄ›tnou vazbu v podobÄ› procentuÃ¡lnÃ­ho hodnocenÃ­ aktuÃ¡lnÃ­ kvality vaÅ¡eho projektu.

PokusnÃ© odevzdÃ¡nÃ­ bude relativnÄ› rychle vyhodnoceno automatickÃ½mi testy a studentÅ¯m zaslÃ¡na informace o procentuÃ¡lnÃ­ sprÃ¡vnosti stÄ›Å¾ejnÃ­ch ÄÃ¡stÃ­ pokusnÄ› odevzdanÃ©ho projektu z hlediska ÄÃ¡sti automatickÃ½ch testÅ¯ (tj. nebude se jednat o finÃ¡lnÃ­ hodnocenÃ­; proto nebudou sdÄ›lovÃ¡ny ani body). VÃ½sledky nejsou nijak bodovÃ¡ny, a proto nebudou individuÃ¡lnÄ› sdÄ›lovÃ¡ny Å¾Ã¡dnÃ© detaily k chybÃ¡m v zaslanÃ½ch projektech, jako je tomu u finÃ¡lnÃ­ho termÃ­nu. VyuÅ¾itÃ­ pokusnÃ©ho termÃ­nu nenÃ­ povinnÃ©, ale jeho nevyuÅ¾itÃ­ mÅ¯Å¾e bÃ½t vzato v Ãºvahu jako pÅ™itÄ›Å¾ujÃ­cÃ­ okolnost v pÅ™Ã­padÄ› rÅ¯znÃ½ch reklamacÃ­.

FormÃ¡lnÃ­ poÅ¾adavky na pokusnÃ© odevzdÃ¡nÃ­ jsou totoÅ¾nÃ© s poÅ¾adavky na finÃ¡lnÃ­ termÃ­n a odevzdÃ¡nÃ­ se bude provÃ¡dÄ›t do speciÃ¡lnÃ­ho termÃ­nu â€Projekt - PokusnÃ© odevzdÃ¡nÃ­â€œ pÅ™edmÄ›tu IFJ. NenÃ­ nutnÃ© zahrnout dokumentaci, kterÃ¡ spolu s rozÅ¡Ã­Å™enÃ­mi pokusnÄ› vyhodnocena nebude. PokusnÄ› odevzdÃ¡vÃ¡ nejvÃ½Å¡e jeden Älen tÃ½mu (nejlÃ©pe vedoucÃ­), kterÃ½ nÃ¡slednÄ› obdrÅ¾Ã­ jeho vyhodnocenÃ­ a informuje zbytek tÃ½mu.

### 12.7 RegistrovanÃ¡ rozÅ¡Ã­Å™enÃ­

V pÅ™Ã­padÄ› implementace nÄ›kterÃ½ch registrovanÃ½ch rozÅ¡Ã­Å™enÃ­ bude odevzdanÃ½ archÃ­v obsahovat soubor rozsireni, ve kterÃ©m uvedete na kaÅ¾dÃ©m Å™Ã¡dku identifikÃ¡tor jednoho implementovanÃ©ho rozÅ¡Ã­Å™enÃ­ (Å™Ã¡dky jsou opÄ›t ukonÄeny znakem âŸ¨LFâŸ©).

V prÅ¯bÄ›hu Å™eÅ¡enÃ­ (do stanovenÃ©ho termÃ­nu) bude postupnÄ› (pÅ™Ã­padnÄ› i na vÃ¡Å¡ popud) aktualizovÃ¡n cenÃ­k rozÅ¡Ã­Å™enÃ­ a identifikÃ¡tory rozÅ¡Ã­Å™enÃ­ projektu (viz wiki strÃ¡nky a diskuznÃ­ fÃ³rum k pÅ™edmÄ›tu IFJ). V nÄ›m budou uvedena hodnocenÃ¡ rozÅ¡Ã­Å™enÃ­ projektu, za kterÃ¡ lze zÃ­skat prÃ©miovÃ© body. CviÄÃ­cÃ­m mÅ¯Å¾ete bÄ›hem semestru zasÃ­lat nÃ¡vrhy na dosud neuvedenÃ¡ rozÅ¡Ã­Å™enÃ­, kterÃ¡ byste chtÄ›li navÃ­c implementovat. CviÄÃ­cÃ­ rozhodnou o pÅ™ijetÃ­/nepÅ™ijetÃ­ rozÅ¡Ã­Å™enÃ­ a hodnocenÃ­ rozÅ¡Ã­Å™enÃ­ dle jeho nÃ¡roÄnosti vÄetnÄ› pÅ™iÅ™azenÃ­ unikÃ¡tnÃ­ho identifikÃ¡toru. Body za implementovanÃ¡ rozÅ¡Ã­Å™enÃ­ se poÄÃ­tajÃ­ do bodÅ¯ za programovou implementaci, takÅ¾e
stÃ¡le platÃ­ zÃ­skatelnÃ© maximum 20 bodÅ¯.

#### 12.7.1 BodovÃ© hodnocenÃ­ nÄ›kterÃ½ch rozÅ¡Ã­Å™enÃ­ jazyka IFJ21

Popis rozÅ¡Ã­Å™enÃ­ vÅ¾dy zaÄÃ­nÃ¡ jeho identifikÃ¡torem. VÄ›tÅ¡ina tÄ›chto rozÅ¡Ã­Å™enÃ­ je zaloÅ¾ena na dalÅ¡Ã­ch vlastnostech jazyka Teal. PodrobnÄ›jÅ¡Ã­ informace lze zÃ­skat ze specifikace jazyka Teal. Do dokumentace je potÅ™eba (kromÄ› zkratky na ÃºvodnÃ­ stranu) takÃ© uvÃ©st, jak jsou implementovanÃ¡ rozÅ¡Ã­Å™enÃ­ Å™eÅ¡ena.
- BOOLTHEN: Podpora typu `boolean`, booleovskÃ½ch hodnot `true` a `false`, booleovskÃ½ch vÃ½razÅ¯ vÄetnÄ› kulatÃ½ch zÃ¡vorek a zÃ¡kladnÃ­ch booleovskÃ½ch operÃ¡torÅ¯ (`not`,
`and`, `or` vÄetnÄ› zkratovÃ©ho vyhodnocenÃ­), jejichÅ¾ priorita a asociativita odpovÃ­dÃ¡ jazyku Teal. PravdivostnÃ­ hodnoty lze porovnÃ¡vat jen operÃ¡tory `==` a `~=`. DÃ¡le podporujte vÃ½pisy hodnot typu boolean a pÅ™iÅ™azovÃ¡nÃ­ vÃ½sledku booleovskÃ©ho vÃ½razu do promÄ›nnÃ©. DÃ¡le podporujte zjednoduÅ¡enÃ½ podmÃ­nÄ›nÃ½ pÅ™Ã­kaz `if` bez ÄÃ¡sti `else` a rozÅ¡Ã­Å™enÃ½ podmÃ­nÄ›nÃ½ pÅ™Ã­kaz s volitelnÃ½m vÃ­cenÃ¡sobnÃ½m vÃ½skytem ÄÃ¡sti `elseif` (+1,5 bodu).
- CYCLES: PÅ™ekladaÄ bude podporovat i cyklus `for` (numerickou variantu) a cyklus `repeat-until`. DÃ¡le bude podporovat ve vÅ¡ech typech iterace klÃ­ÄovÃ© slovo break
(+1,5 bodu).
- FUNEXP: VolÃ¡nÃ­ funkce mÅ¯Å¾e bÃ½t souÄÃ¡stÃ­ vÃ½razu, zÃ¡roveÅˆ mohou bÃ½t vÃ½razy v parametrech volÃ¡nÃ­ funkce (+1,5 bodu).
- OPERATORS: RozÅ¡Ã­Å™enÃ­ zavÃ¡dÃ­ podporu pro unÃ¡rnÃ­m operÃ¡tor âˆ’ (unÃ¡rnÃ­ mÃ­nus) a binÃ¡rnÃ­ aritmetickÃ© operÃ¡tory % a ^. SÃ©mantika, priorita a asociativita tÄ›chto operÃ¡torÅ¯ odpovÃ­dÃ¡ jazyku Teal. DÃ¡le je moÅ¾nÃ© ve zdrojovÃ©m kÃ³du IFJ21 pouÅ¾Ã­vat zÃ¡pornÃ© ÄÃ­selnÃ© literÃ¡ly (tj. jako term) (+0,5 bodu).

## 13 Opravy zadÃ¡nÃ­
- 24\. 9. 2021 â€“ Oprava pÅ™eklepÅ¯ v pÅ™Ã­kladech (printâ†’write); bÃ­lÃ© znaky mezi pÅ™Ã­kazy nejsou vÅ¾dy nezbytnÃ©.
- 25\. 9. 2021 â€“ VypuÅ¡tÄ›nÃ­ klÃ­ÄovÃ½ch slov read a write (identifikÃ¡tory vestavÄ›nÃ½ch funkcÃ­ nejsou klÃ­ÄovÃ¡ slova); Ãºprava sÃ©mantiky pÅ™Ã­kazu volÃ¡nÃ­ funkce pÅ™i Å¡patnÃ©m poÄtu vracenÃ½ch hodnot; oprava pÅ™eklepÅ¯ a upÅ™esnÄ›nÃ­ formulacÃ­.
- 28\. 9. 2021 â€“ DoplnÄ›nÃ­ poÅ¾adavku na dokumentaci ohlednÄ› popisu rozdÄ›lenÃ­ implementace na zdrojovÃ© soubory; oprava/doplnÄ›nÃ­ sÃ©mantiky vestavÄ›nÃ½ch funkcÃ­ (pÅ™edevÅ¡Ã­m tÄ›ch pro prÃ¡ci s Å™etÄ›zci); oprava pÅ™Ã­kladu 1 a 3; doplnÄ›nÃ­ rozÅ¡Ã­Å™enÃ­ OPERATORS.
